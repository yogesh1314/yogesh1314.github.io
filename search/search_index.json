{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This site helps me to log my learning kdb+/q Python HTML/CSS/JS","title":"Home"},{"location":"kdb-q/Qsql/1_using_select_statements/","text":"Using Select Statements Select Select is used to extract a subset of data from a table general form select [column/s] [by columns] from table_name where [condition/s] select statement is executed in order: from table_name where [condition/s] [by columns] select [columns] example table: q)sales:([]fruit:10?`apple`banana`orange;grocer:10?`ram`krishna`laxman;price:10?10;qty:10?100) / sales table is defined q)sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 select from table_name in select if no columns are queried - it will select all columns from the table in its basic format - from is only required condition, all other(by, where, select) are optional q)select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 select column/s from table_name select columns separated by , even if single column is asked return type is table q)select fruit, price from sales fruit price ------------ orange 6 apple 6 apple 1 orange 8 apple 5 banana 4 apple 9 apple 2 apple 7 orange 0 q)select fruit from sales fruit ------ orange apple apple orange apple banana apple apple apple orange q)type select fruit from sales 98h select column/s from table_name where condition/s q)select fruit, price from sales where fruit=`apple fruit price ----------- apple 6 apple 1 apple 5 apple 9 apple 2 apple 7 select column/s by column/s from table_name grouping data by column/s q)select fruit, price by grocer from sales grocer | fruit price -------| ------------------------------------------ krishna| `orange`apple`apple`apple`orange 6 1 5 2 0 laxman | `apple`orange`apple 6 8 7 ram | `banana`apple 4 9 we can apply aggregation to grouped data - select aggregate_function column/s by column/s from table_name q)select sum price by grocer from sales grocer | price -------| ----- krishna| 14 laxman | 21 ram | 13 q)select notional: sum price*qty by grocer from sales grocer | notional -------| -------- krishna| 618 laxman | 1368 ram | 747 if we don't query any select columns then all the columns are grouped by by column/s and last aggregate_function is applied by default q)select by grocer from sales grocer | fruit price qty -------| ---------------- krishna| orange 0 63 laxman | apple 7 84 ram | apple 9 43 select[+/- n] from table_name returns n rows from start q)select[3] from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 if n < 0; returns n rows from end of table q)select[-3] from sales fruit grocer price qty ------------------------ apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 same can be applied to result set after the select is performed n sublist select from table_name q)3 sublist select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 select[m n] from table_name returns n rows starting from index m q)select[3 4] from sales fruit grocer price qty ------------------------ orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 same can be applied to result set after select is performed m n sublist select from table_name q)3 4 sublist select from sales fruit grocer price qty ------------------------ orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 select[ column/s] from table_name < means ascending order > means descending order q)select[>grocer] from sales fruit grocer price qty ------------------------ banana ram 4 90 apple ram 9 43 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 same can be done using functions xasc and xdesc to sort the result table into ascending or descending order respectively - column/s xasc/xdesc select from table_name q)`grocer xasc select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 banana ram 4 90 apple ram 9 43 q)`grocer xdesc select from sales fruit grocer price qty ------------------------ banana ram 4 90 apple ram 9 43 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 all above points can also be combined q)select[3;<price] fruit, price from sales where fruit in `apple fruit price ----------- apple 1 apple 2 apple 5 Exec general form : exec column/s by column/s from table_name where condition/s can return data with type different than table, whereas select always returns data with type=table(98h) exec can only be applied to in-memory tables exec column/s from table_name q)exec fruit from sales `orange`apple`apple`orange`apple`banana`apple`apple`apple`orange q)type exec fruit from sales 11h q)exec fruit,price from sales fruit| orange apple apple orange apple banana apple apple apple orange price| 6 6 1 8 5 4 9 2 7 0 q)type exec fruit,price from sales 99h exec column/s!column/s from table_name return type is dictionary keys are column/s before ! and values are ones after it q)exec fruit!price from sales orange| 6 apple | 6 apple | 1 orange| 8 apple | 5 banana| 4 apple | 9 apple | 2 apple | 7 orange| 0 exec column/s!column/s by column/s from table_name q)exec fruit!price by grocer from sales krishna| `orange`apple`apple`apple`orange!6 1 5 2 0 laxman | `apple`orange`apple!6 8 7 ram | `banana`apple!4 9 Update update allows us to add/modify columns from table general form: update column_name/s: aggr column_name/s by column/s from table_name where condition/s update new_column_name:aggr[column1;column2] from table_name q)update notional:price*qty from sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0 update by default won't make changes to table, we can make changes into table by referring to table_name in update query as symbol - update x:y from ``table_name q)update notional:price*qty from sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0 q)sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 q)update notional:price*qty from `sales `sales q)sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0 Delete used to delete columns from table general form is same as update/select delete column/s from table_name q)delete price from sales fruit grocer qty notional --------------------------- orange krishna 12 72 apple laxman 10 60 apple krishna 1 1 orange laxman 90 720 apple krishna 73 365 banana ram 90 360 apple ram 43 387 apple krishna 90 180 apple laxman 84 588 orange krishna 63 0 delete from table_name where condition/s q)delete from sales where fruit=`apple fruit grocer qty notional --------------------------- orange krishna 12 72 orange laxman 90 720 banana ram 90 360 orange krishna 63 0 we need to provide table_name as symbol to make changes permanent q)delete notional from sales fruit grocer qty ------------------ orange krishna 12 apple laxman 10 apple krishna 1 orange laxman 90 apple krishna 73 banana ram 90 apple ram 43 apple krishna 90 apple laxman 84 orange krishna 63 q)sales fruit grocer qty notional --------------------------- orange krishna 12 72 apple laxman 10 60 apple krishna 1 1 orange laxman 90 720 apple krishna 73 365 banana ram 90 360 apple ram 43 387 apple krishna 90 180 apple laxman 84 588 orange krishna 63 0 q)delete notional from `sales `sales q)sales fruit grocer qty ------------------ orange krishna 12 apple laxman 10 apple krishna 1 orange laxman 90 apple krishna 73 banana ram 90 apple ram 43 apple krishna 90 apple laxman 84 orange krishna 63 we can also use delete to remove entities from our workspace q)tables[] ,`sales q)delete sales from `. `. q)tables[] `symbol$() q)sales 'sales [0] sales ^ q) we can also delete everything from current workspace using delete q)delete from `. `. Insert general form table_name_as_symbol insert (values;as;column;types) returned is the index number where rows are added into the table q)cars:([]brand:`symbol$();model:`symbol$();purchasedate:`date$()) q)cars brand model purchasedate ------------------------ q)`cars insert (`bmw;`z4;2020.01.01) ,0 q)cars brand model purchasedate ------------------------ bmw z4 2020.01.01 more than 1 record can be added with values as list of lists q)`cars insert (`tata`mahindra;`nexon`xuv500;2020.12.01 2020.10.02) 1 2 q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 we can also insert entire table, provided schema matches same can be done using ,: adverb q)`cars insert cars 3 4 5 q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 q)cars,:cars q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 Upsert can be used for both - keyed and unkeyed tables it will modify a row if it already exists and add if it doesn't q)fruitprice:([fruit:`apple`banana] price:100 20; quantity:20 400) q)fruitprice fruit | price quantity ------| -------------- apple | 100 20 banana| 20 400 q)`fruitprice upsert (`apple;150;30) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 in order to add more than 1 row, we need to upsert a table q)`fruitprice upsert (`apple`orange;150 30;30 50) 'length [0] `fruitprice upsert (`apple`orange;150 30;30 50) ^ q)`fruitprice upsert ([fruit:`apple`orange];price: 150 30;quantity: 30 50) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 orange| 30 50 upsert will work if order of columns are different or column values are missing q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 orange| 30 50 q)`fruitprice upsert (fruit:`apple;price: 200 ;quantity: 20) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 200 20 banana| 20 400 orange| 30 50 q)`fruitprice upsert ([]price:175 40;fruit:`apple`kiwi) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 175 20 banana| 20 400 orange| 30 50 kiwi | 40","title":"Select"},{"location":"kdb-q/Qsql/1_using_select_statements/#using-select-statements","text":"","title":"Using Select Statements"},{"location":"kdb-q/Qsql/1_using_select_statements/#select","text":"Select is used to extract a subset of data from a table general form select [column/s] [by columns] from table_name where [condition/s] select statement is executed in order: from table_name where [condition/s] [by columns] select [columns] example table: q)sales:([]fruit:10?`apple`banana`orange;grocer:10?`ram`krishna`laxman;price:10?10;qty:10?100) / sales table is defined q)sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 select from table_name in select if no columns are queried - it will select all columns from the table in its basic format - from is only required condition, all other(by, where, select) are optional q)select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 select column/s from table_name select columns separated by , even if single column is asked return type is table q)select fruit, price from sales fruit price ------------ orange 6 apple 6 apple 1 orange 8 apple 5 banana 4 apple 9 apple 2 apple 7 orange 0 q)select fruit from sales fruit ------ orange apple apple orange apple banana apple apple apple orange q)type select fruit from sales 98h select column/s from table_name where condition/s q)select fruit, price from sales where fruit=`apple fruit price ----------- apple 6 apple 1 apple 5 apple 9 apple 2 apple 7 select column/s by column/s from table_name grouping data by column/s q)select fruit, price by grocer from sales grocer | fruit price -------| ------------------------------------------ krishna| `orange`apple`apple`apple`orange 6 1 5 2 0 laxman | `apple`orange`apple 6 8 7 ram | `banana`apple 4 9 we can apply aggregation to grouped data - select aggregate_function column/s by column/s from table_name q)select sum price by grocer from sales grocer | price -------| ----- krishna| 14 laxman | 21 ram | 13 q)select notional: sum price*qty by grocer from sales grocer | notional -------| -------- krishna| 618 laxman | 1368 ram | 747 if we don't query any select columns then all the columns are grouped by by column/s and last aggregate_function is applied by default q)select by grocer from sales grocer | fruit price qty -------| ---------------- krishna| orange 0 63 laxman | apple 7 84 ram | apple 9 43 select[+/- n] from table_name returns n rows from start q)select[3] from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 if n < 0; returns n rows from end of table q)select[-3] from sales fruit grocer price qty ------------------------ apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 same can be applied to result set after the select is performed n sublist select from table_name q)3 sublist select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 select[m n] from table_name returns n rows starting from index m q)select[3 4] from sales fruit grocer price qty ------------------------ orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 same can be applied to result set after select is performed m n sublist select from table_name q)3 4 sublist select from sales fruit grocer price qty ------------------------ orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 select[ column/s] from table_name < means ascending order > means descending order q)select[>grocer] from sales fruit grocer price qty ------------------------ banana ram 4 90 apple ram 9 43 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 same can be done using functions xasc and xdesc to sort the result table into ascending or descending order respectively - column/s xasc/xdesc select from table_name q)`grocer xasc select from sales fruit grocer price qty ------------------------ orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 banana ram 4 90 apple ram 9 43 q)`grocer xdesc select from sales fruit grocer price qty ------------------------ banana ram 4 90 apple ram 9 43 apple laxman 6 10 orange laxman 8 90 apple laxman 7 84 orange krishna 6 12 apple krishna 1 1 apple krishna 5 73 apple krishna 2 90 orange krishna 0 63 all above points can also be combined q)select[3;<price] fruit, price from sales where fruit in `apple fruit price ----------- apple 1 apple 2 apple 5","title":"Select"},{"location":"kdb-q/Qsql/1_using_select_statements/#exec","text":"general form : exec column/s by column/s from table_name where condition/s can return data with type different than table, whereas select always returns data with type=table(98h) exec can only be applied to in-memory tables exec column/s from table_name q)exec fruit from sales `orange`apple`apple`orange`apple`banana`apple`apple`apple`orange q)type exec fruit from sales 11h q)exec fruit,price from sales fruit| orange apple apple orange apple banana apple apple apple orange price| 6 6 1 8 5 4 9 2 7 0 q)type exec fruit,price from sales 99h exec column/s!column/s from table_name return type is dictionary keys are column/s before ! and values are ones after it q)exec fruit!price from sales orange| 6 apple | 6 apple | 1 orange| 8 apple | 5 banana| 4 apple | 9 apple | 2 apple | 7 orange| 0 exec column/s!column/s by column/s from table_name q)exec fruit!price by grocer from sales krishna| `orange`apple`apple`apple`orange!6 1 5 2 0 laxman | `apple`orange`apple!6 8 7 ram | `banana`apple!4 9","title":"Exec"},{"location":"kdb-q/Qsql/1_using_select_statements/#update","text":"update allows us to add/modify columns from table general form: update column_name/s: aggr column_name/s by column/s from table_name where condition/s update new_column_name:aggr[column1;column2] from table_name q)update notional:price*qty from sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0 update by default won't make changes to table, we can make changes into table by referring to table_name in update query as symbol - update x:y from ``table_name q)update notional:price*qty from sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0 q)sales fruit grocer price qty ------------------------ orange krishna 6 12 apple laxman 6 10 apple krishna 1 1 orange laxman 8 90 apple krishna 5 73 banana ram 4 90 apple ram 9 43 apple krishna 2 90 apple laxman 7 84 orange krishna 0 63 q)update notional:price*qty from `sales `sales q)sales fruit grocer price qty notional --------------------------------- orange krishna 6 12 72 apple laxman 6 10 60 apple krishna 1 1 1 orange laxman 8 90 720 apple krishna 5 73 365 banana ram 4 90 360 apple ram 9 43 387 apple krishna 2 90 180 apple laxman 7 84 588 orange krishna 0 63 0","title":"Update"},{"location":"kdb-q/Qsql/1_using_select_statements/#delete","text":"used to delete columns from table general form is same as update/select delete column/s from table_name q)delete price from sales fruit grocer qty notional --------------------------- orange krishna 12 72 apple laxman 10 60 apple krishna 1 1 orange laxman 90 720 apple krishna 73 365 banana ram 90 360 apple ram 43 387 apple krishna 90 180 apple laxman 84 588 orange krishna 63 0 delete from table_name where condition/s q)delete from sales where fruit=`apple fruit grocer qty notional --------------------------- orange krishna 12 72 orange laxman 90 720 banana ram 90 360 orange krishna 63 0 we need to provide table_name as symbol to make changes permanent q)delete notional from sales fruit grocer qty ------------------ orange krishna 12 apple laxman 10 apple krishna 1 orange laxman 90 apple krishna 73 banana ram 90 apple ram 43 apple krishna 90 apple laxman 84 orange krishna 63 q)sales fruit grocer qty notional --------------------------- orange krishna 12 72 apple laxman 10 60 apple krishna 1 1 orange laxman 90 720 apple krishna 73 365 banana ram 90 360 apple ram 43 387 apple krishna 90 180 apple laxman 84 588 orange krishna 63 0 q)delete notional from `sales `sales q)sales fruit grocer qty ------------------ orange krishna 12 apple laxman 10 apple krishna 1 orange laxman 90 apple krishna 73 banana ram 90 apple ram 43 apple krishna 90 apple laxman 84 orange krishna 63 we can also use delete to remove entities from our workspace q)tables[] ,`sales q)delete sales from `. `. q)tables[] `symbol$() q)sales 'sales [0] sales ^ q) we can also delete everything from current workspace using delete q)delete from `. `.","title":"Delete"},{"location":"kdb-q/Qsql/1_using_select_statements/#insert","text":"general form table_name_as_symbol insert (values;as;column;types) returned is the index number where rows are added into the table q)cars:([]brand:`symbol$();model:`symbol$();purchasedate:`date$()) q)cars brand model purchasedate ------------------------ q)`cars insert (`bmw;`z4;2020.01.01) ,0 q)cars brand model purchasedate ------------------------ bmw z4 2020.01.01 more than 1 record can be added with values as list of lists q)`cars insert (`tata`mahindra;`nexon`xuv500;2020.12.01 2020.10.02) 1 2 q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 we can also insert entire table, provided schema matches same can be done using ,: adverb q)`cars insert cars 3 4 5 q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 q)cars,:cars q)cars brand model purchasedate ---------------------------- bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02 bmw z4 2020.01.01 tata nexon 2020.12.01 mahindra xuv500 2020.10.02","title":"Insert"},{"location":"kdb-q/Qsql/1_using_select_statements/#upsert","text":"can be used for both - keyed and unkeyed tables it will modify a row if it already exists and add if it doesn't q)fruitprice:([fruit:`apple`banana] price:100 20; quantity:20 400) q)fruitprice fruit | price quantity ------| -------------- apple | 100 20 banana| 20 400 q)`fruitprice upsert (`apple;150;30) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 in order to add more than 1 row, we need to upsert a table q)`fruitprice upsert (`apple`orange;150 30;30 50) 'length [0] `fruitprice upsert (`apple`orange;150 30;30 50) ^ q)`fruitprice upsert ([fruit:`apple`orange];price: 150 30;quantity: 30 50) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 orange| 30 50 upsert will work if order of columns are different or column values are missing q)fruitprice fruit | price quantity ------| -------------- apple | 150 30 banana| 20 400 orange| 30 50 q)`fruitprice upsert (fruit:`apple;price: 200 ;quantity: 20) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 200 20 banana| 20 400 orange| 30 50 q)`fruitprice upsert ([]price:175 40;fruit:`apple`kiwi) `fruitprice q)fruitprice fruit | price quantity ------| -------------- apple | 175 20 banana| 20 400 orange| 30 50 kiwi | 40","title":"Upsert"},{"location":"kdb-q/Qsql/2_where_clause/","text":"Where Clause used to filter data from in-memory and on-disk tables q)tab:([]price:1000000?100f;qty:1000000?100) q)tab price qty ------------ 68.78151 92 1.897575 93 56.70071 84 48.33407 20 82.02713 22 .. where clause cascades the data - filter conditions are applied in order they are written and only subset of data is passed to next one we need to be careful about the order of filter conditions we should be cutting the dataset into as small as possible as fast as possible filter conditions are applied left to right - thus if we apply price filter first less number of rows are left for applying qty filter, similarly if we apply qty filter first then price filter is applied to more number of rows thus taking more time q)count select from tab where qty<90 899773 q)count select from tab where price>50 500309 q)\\t select from tab where price>50, qty<90 64 q)\\t select from tab where qty<90, price>50 77 Historic database we should apply where first on partition if partitioned by date, first filter condition should be on date there is a huge difference in fetching data from HDB if first filter is not partition(date/month/year) q)\\l fakedb.q q)makehdb[`:hdb;10;100000;10] 2020.12.24T10:09:26.303 saving data for date 2014.04.21 to :hdb 2020.12.24T10:09:27.947 saving data for date 2014.04.22 to :hdb 2020.12.24T10:09:29.396 saving data for date 2014.04.23 to :hdb 2020.12.24T10:09:31.115 saving data for date 2014.04.24 to :hdb 2020.12.24T10:09:33.085 saving data for date 2014.04.25 to :hdb 2020.12.24T10:09:34.825 saving data for date 2014.04.28 to :hdb 2020.12.24T10:09:36.320 saving data for date 2014.04.29 to :hdb 2020.12.24T10:09:38.063 saving data for date 2014.04.30 to :hdb 2020.12.24T10:09:40.130 saving data for date 2014.05.01 to :hdb 2020.12.24T10:09:42.148 saving data for date 2014.05.02 to :hdb q)\\l hdb q)q)count quotes 1027292 q)select distinct date from quotes date ---------- 2014.04.21 2014.04.22 2014.04.23 2014.04.24 2014.04.25 2014.04.28 2014.04.29 2014.04.30 2014.05.01 2014.05.02 q) // HDB created and loaded query without date as first filter q)\\t:100 select from quotes where sym=`AAPL, bsize>5000, date=2014.04.21 2849 query with date as first filter q)\\t:100 select from quotes where date=2014.04.21, sym=`AAPL, bsize>5000 328 difference is almost 7 times which is quite huge Attributes if attributes are present in table - can be checked using meta table_name in where we should use attributes columns just after partition columns, thus for on-disk table where filter order would be: partition column columns with attributes other columns and for in-memory tables where order would be: columns with attributes other columns q)meta quotes c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)\\t:100 select from quotes where date=2014.04.23, sym=`AAPL,bid>10 370 q)\\t:100 select from quotes where date=2014.04.23, bid>10, sym=`AAPL 1035 q) // difference is almost 3 times tuple matches allows us to apply multiple filters on same columns in single query eg: we want IBM trades from src L, CSCO trades from src L or N and MSFT trades from src O method 1: apply where individually and join results q)(select from trades where date=2014.04.21, sym=`IBM, src=`L),(select from trades where date=2014.04.21, sym=`MSFT, src in `O),(select from trades where date=2014.04.21, sym=`CSCO, src in `L`N) date sym time src price size ------------------------------------------------------------ 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D12:56:35.834000000 L 42.36 3389 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 method 2: use tuple matches we define our conditions in a table apply where with condition table q)toget:([]sym:`IBM`MSFT`CSCO`CSCO;src:`L`O`L`N) q)toget sym src -------- IBM L MSFT O CSCO L CSCO N q)select from trades where date=2014.04.21, ([]sym; src) in toget date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D12:56:35.834000000 L 42.36 3389 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 q)\\t:1000 select from trades where date=2014.04.21, ([]sym; src) in toget 1613 we can also attributes to bring down query time further down q)\\t:1000 select from trades where date=2014.04.21, sym in toget`sym, ([]sym; src) in toget 1397 q) // around 200ms difference Where clause ordering while applying where clause ordering is most important part eg: in a sample table trades q)trades:([]price:50 51 70; size: 600 800 300) q)trades price size ---------- 50 600 51 800 70 300 we want to search for trades which occurred at max price also has size more than 500 from looking at table trades we see there is no such trade but if we are not careful in the order of where conditions we can get incorrect results q)select from trades where size>500, price=max price price size ---------- 51 800 q) // this result is incorrect we get incorrect result - because price filter should have been applied on whole trades table, instead it is applied result of size filter query with correct order would be q)select from trades where price=max price, size>500 price size ---------- which results into 0 such trades, which is correct fby - filter by used to apply aggregations within the where clause eg: get trades with max price for each sym for a date q)// first attempt q)select from trades where date=2014.04.21, price=max price date sym time src price size ----------------------------------------------------------- 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 but this will only give us trades with max price across all syms not for each syms q)// second attempt q)select by sym from trades where date=2014.04.21, price=max price sym| date time src price size ---| ------------------------------------------------------- IBM| 2014.04.21 2014.04.21D09:35:14.517000000 L 43.37 6771 this also fails as where clause is applied before by clause q) // using fby - apply aggregation of max price and filter by sym q)select from trades where date=2014.04.21, price=(max;price) fby sym date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 DELL 2014.04.21D13:15:14.289000000 L 29.63 1490 2014.04.21 GOOG 2014.04.21D13:57:48.315000000 L 41.4 989 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 NOK 2014.04.21D15:06:51.099000000 N 31.64 4452 2014.04.21 ORCL 2014.04.21D12:28:32.455000000 L 32.6 15 q) // now this seems, right !! we can also aggregate by more than 1 field (sym, src, etc..) q)select from trades where date=2014.04.21, price=(max;price) fby ([]sym;src) date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 DELL 2014.04.21D13:15:14.289000000 L 29.63 1490 2014.04.21 GOOG 2014.04.21D13:57:48.315000000 L 41.4 989 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D16:09:21.276000000 O 41.89 4567 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 NOK 2014.04.21D15:06:51.099000000 N 31.64 4452 2014.04.21 ORCL 2014.04.21D12:28:32.455000000 L 32.6 15 2014.04.21 ORCL 2014.04.21D16:19:28.873000000 N 31.33 2269","title":"Where"},{"location":"kdb-q/Qsql/2_where_clause/#where-clause","text":"used to filter data from in-memory and on-disk tables q)tab:([]price:1000000?100f;qty:1000000?100) q)tab price qty ------------ 68.78151 92 1.897575 93 56.70071 84 48.33407 20 82.02713 22 .. where clause cascades the data - filter conditions are applied in order they are written and only subset of data is passed to next one we need to be careful about the order of filter conditions we should be cutting the dataset into as small as possible as fast as possible filter conditions are applied left to right - thus if we apply price filter first less number of rows are left for applying qty filter, similarly if we apply qty filter first then price filter is applied to more number of rows thus taking more time q)count select from tab where qty<90 899773 q)count select from tab where price>50 500309 q)\\t select from tab where price>50, qty<90 64 q)\\t select from tab where qty<90, price>50 77","title":"Where Clause"},{"location":"kdb-q/Qsql/2_where_clause/#historic-database","text":"we should apply where first on partition if partitioned by date, first filter condition should be on date there is a huge difference in fetching data from HDB if first filter is not partition(date/month/year) q)\\l fakedb.q q)makehdb[`:hdb;10;100000;10] 2020.12.24T10:09:26.303 saving data for date 2014.04.21 to :hdb 2020.12.24T10:09:27.947 saving data for date 2014.04.22 to :hdb 2020.12.24T10:09:29.396 saving data for date 2014.04.23 to :hdb 2020.12.24T10:09:31.115 saving data for date 2014.04.24 to :hdb 2020.12.24T10:09:33.085 saving data for date 2014.04.25 to :hdb 2020.12.24T10:09:34.825 saving data for date 2014.04.28 to :hdb 2020.12.24T10:09:36.320 saving data for date 2014.04.29 to :hdb 2020.12.24T10:09:38.063 saving data for date 2014.04.30 to :hdb 2020.12.24T10:09:40.130 saving data for date 2014.05.01 to :hdb 2020.12.24T10:09:42.148 saving data for date 2014.05.02 to :hdb q)\\l hdb q)q)count quotes 1027292 q)select distinct date from quotes date ---------- 2014.04.21 2014.04.22 2014.04.23 2014.04.24 2014.04.25 2014.04.28 2014.04.29 2014.04.30 2014.05.01 2014.05.02 q) // HDB created and loaded query without date as first filter q)\\t:100 select from quotes where sym=`AAPL, bsize>5000, date=2014.04.21 2849 query with date as first filter q)\\t:100 select from quotes where date=2014.04.21, sym=`AAPL, bsize>5000 328 difference is almost 7 times which is quite huge","title":"Historic database"},{"location":"kdb-q/Qsql/2_where_clause/#attributes","text":"if attributes are present in table - can be checked using meta table_name in where we should use attributes columns just after partition columns, thus for on-disk table where filter order would be: partition column columns with attributes other columns and for in-memory tables where order would be: columns with attributes other columns q)meta quotes c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)\\t:100 select from quotes where date=2014.04.23, sym=`AAPL,bid>10 370 q)\\t:100 select from quotes where date=2014.04.23, bid>10, sym=`AAPL 1035 q) // difference is almost 3 times","title":"Attributes"},{"location":"kdb-q/Qsql/2_where_clause/#tuple-matches","text":"allows us to apply multiple filters on same columns in single query eg: we want IBM trades from src L, CSCO trades from src L or N and MSFT trades from src O method 1: apply where individually and join results q)(select from trades where date=2014.04.21, sym=`IBM, src=`L),(select from trades where date=2014.04.21, sym=`MSFT, src in `O),(select from trades where date=2014.04.21, sym=`CSCO, src in `L`N) date sym time src price size ------------------------------------------------------------ 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D12:56:35.834000000 L 42.36 3389 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 method 2: use tuple matches we define our conditions in a table apply where with condition table q)toget:([]sym:`IBM`MSFT`CSCO`CSCO;src:`L`O`L`N) q)toget sym src -------- IBM L MSFT O CSCO L CSCO N q)select from trades where date=2014.04.21, ([]sym; src) in toget date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D12:56:35.834000000 L 42.36 3389 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 q)\\t:1000 select from trades where date=2014.04.21, ([]sym; src) in toget 1613 we can also attributes to bring down query time further down q)\\t:1000 select from trades where date=2014.04.21, sym in toget`sym, ([]sym; src) in toget 1397 q) // around 200ms difference","title":"tuple matches"},{"location":"kdb-q/Qsql/2_where_clause/#where-clause-ordering","text":"while applying where clause ordering is most important part eg: in a sample table trades q)trades:([]price:50 51 70; size: 600 800 300) q)trades price size ---------- 50 600 51 800 70 300 we want to search for trades which occurred at max price also has size more than 500 from looking at table trades we see there is no such trade but if we are not careful in the order of where conditions we can get incorrect results q)select from trades where size>500, price=max price price size ---------- 51 800 q) // this result is incorrect we get incorrect result - because price filter should have been applied on whole trades table, instead it is applied result of size filter query with correct order would be q)select from trades where price=max price, size>500 price size ---------- which results into 0 such trades, which is correct","title":"Where clause ordering"},{"location":"kdb-q/Qsql/2_where_clause/#fby-filter-by","text":"used to apply aggregations within the where clause eg: get trades with max price for each sym for a date q)// first attempt q)select from trades where date=2014.04.21, price=max price date sym time src price size ----------------------------------------------------------- 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 but this will only give us trades with max price across all syms not for each syms q)// second attempt q)select by sym from trades where date=2014.04.21, price=max price sym| date time src price size ---| ------------------------------------------------------- IBM| 2014.04.21 2014.04.21D09:35:14.517000000 L 43.37 6771 this also fails as where clause is applied before by clause q) // using fby - apply aggregation of max price and filter by sym q)select from trades where date=2014.04.21, price=(max;price) fby sym date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 DELL 2014.04.21D13:15:14.289000000 L 29.63 1490 2014.04.21 GOOG 2014.04.21D13:57:48.315000000 L 41.4 989 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 NOK 2014.04.21D15:06:51.099000000 N 31.64 4452 2014.04.21 ORCL 2014.04.21D12:28:32.455000000 L 32.6 15 q) // now this seems, right !! we can also aggregate by more than 1 field (sym, src, etc..) q)select from trades where date=2014.04.21, price=(max;price) fby ([]sym;src) date sym time src price size ------------------------------------------------------------ 2014.04.21 CSCO 2014.04.21D08:20:47.172000000 N 35.74 1615 2014.04.21 DELL 2014.04.21D13:15:14.289000000 L 29.63 1490 2014.04.21 GOOG 2014.04.21D13:57:48.315000000 L 41.4 989 2014.04.21 IBM 2014.04.21D09:35:14.517000000 L 43.37 6771 2014.04.21 IBM 2014.04.21D16:09:21.276000000 O 41.89 4567 2014.04.21 MSFT 2014.04.21D08:30:37.642000000 O 36.4 855 2014.04.21 NOK 2014.04.21D15:06:51.099000000 N 31.64 4452 2014.04.21 ORCL 2014.04.21D12:28:32.455000000 L 32.6 15 2014.04.21 ORCL 2014.04.21D16:19:28.873000000 N 31.33 2269","title":"fby - filter by"},{"location":"kdb-q/Qsql/3_by_clause/","text":"The by clause used to group data tables are set of lists q)/setup q)makedb[1000000;200000] tables[] q)`depth`quotes`trades we can apply group data using by without aggregation - aggregation function last is applied by default q)select by sym from trades sym | time src price size ----| -------------------------------------------- AAPL| 2020.12.25D16:29:55.722000000 N 29.89 210 CSCO| 2020.12.25D16:29:56.120000000 O 35.29 2803 DELL| 2020.12.25D16:29:57.739000000 N 28.66 1889 GOOG| 2020.12.25D16:29:56.958000000 N 43.87 1254 IBM | 2020.12.25D16:29:58.656000000 N 37.92 4379 MSFT| 2020.12.25D16:29:59.677000000 L 38.88 6493 NOK | 2020.12.25D16:29:57.448000000 N 34.55 1092 ORCL| 2020.12.25D16:29:57.487000000 L 31.47 2685 YHOO| 2020.12.25D16:29:59.662000000 N 37.01 5305 grouping with aggregation also works q)select max price, sum size by sym from trades sym | price size ----| -------------- AAPL| 30.39 59274749 CSCO| 38.11 58247173 DELL| 31.11 58330222 GOOG| 44.02 57776533 IBM | 43.6 58945930 MSFT| 41.2 58150838 NOK | 35.56 57899767 ORCL| 33.46 58335324 YHOO| 38.11 59446175 in case of grouping by 2 columns, they are grouped in order they are queried in example below, it's grouped first by sym and then again by src q)select max price, sum size by sym,src from trades sym src| price size --------| -------------- AAPL L | 30.36 20012403 AAPL N | 30.39 19782620 AAPL O | 30.33 19479726 CSCO L | 38.08 19537950 CSCO N | 38.11 19351658 CSCO O | 38.1 19357565 DELL L | 31.09 19188543 DELL N | 31.09 19677846 DELL O | 31.11 19463833 GOOG L | 44.02 19686298 GOOG N | 43.95 19884630 GOOG O | 44.02 18205605 IBM L | 43.55 19806381 IBM N | 43.54 19809111 IBM O | 43.6 19330438 MSFT L | 41.2 19272596 MSFT N | 41.17 19105562 MSFT O | 41.19 19772680 NOK L | 35.49 19366132 NOK N | 35.56 19586497 we can also get values without aggregation q)select max price, size by sym,src from trades sym src| price size .. --------| -------------------------------------------------------------------.. AAPL L | 30.36 1344 922 1223 9988 5087 4250 384 6328 3506 4901 1216 6507 236.. AAPL N | 30.39 119 7205 125 137 2385 6201 5277 781 434 778 5221 165 3665 697.. AAPL O | 30.33 1132 4958 4875 2746 1006 686 636 3929 4680 7888 8422 4246 268.. CSCO L | 38.08 36 3243 1037 2923 994 2832 1613 1530 452 1381 1334 9846 1676 .. CSCO N | 38.11 2144 1363 7463 5020 2068 1329 2075 4074 549 5471 812 7790 251.. CSCO O | 38.1 154 2171 797 1579 1868 2098 2910 1525 921 744 2132 6843 3296 .. DELL L | 31.09 4317 4648 27 5416 1379 3476 2331 154 1246 5158 558 5662 4337 .. DELL N | 31.09 2356 357 170 5101 460 2933 751 4031 1950 4837 5847 5596 244 1.. DELL O | 31.11 22 7472 376 440 2789 1247 520 3012 272 5445 6697 581 1201 108.. data is sorted by columns in ascending order of by clause in example below trades are first sorted ascending by time then by sym q)select max price by time, sym from trades time sym | price ----------------------------------| ----- 2020.12.25D08:00:00.029000000 CSCO| 35.46 2020.12.25D08:00:00.229000000 NOK | 31.82 2020.12.25D08:00:00.250000000 YHOO| 35.5 2020.12.25D08:00:00.861000000 GOOG| 41.41 2020.12.25D08:00:00.946000000 IBM | 43.54 2020.12.25D08:00:00.958000000 MSFT| 36.09 2020.12.25D08:00:01.156000000 CSCO| 35.46 2020.12.25D08:00:01.255000000 NOK | 31.78 2020.12.25D08:00:01.272000000 MSFT| 36.09 2020.12.25D08:00:01.527000000 NOK | 31.76 2020.12.25D08:00:01.546000000 AAPL| 25.36 2020.12.25D08:00:01.629000000 MSFT| 36.08 2020.12.25D08:00:01.680000000 YHOO| 35.54 2020.12.25D08:00:01.836000000 DELL| 29.07 2020.12.25D08:00:01.889000000 CSCO| 35.45 2020.12.25D08:00:02.127000000 DELL| 29.07 2020.12.25D08:00:02.161000000 YHOO| 35.5 2020.12.25D08:00:02.824000000 YHOO| 35.5 2020.12.25D08:00:03.191000000 YHOO| 35.52 2020.12.25D08:00:03.309000000 GOOG| 41.3 HLOC/OHLC high, low, open and close / open, high, low and close q)select high:max price, low:min price, open:first price, close:last price by sym from trades sym | high low open close ----| ----------------------- AAPL| 30.39 24.61 25.36 29.89 CSCO| 38.11 34.25 35.46 35.29 DELL| 31.11 28.48 29.07 28.66 GOOG| 44.02 39.9 41.41 43.87 IBM | 43.6 37.66 43.54 37.92 MSFT| 41.2 35.9 36.09 38.88 NOK | 35.56 29.09 31.82 34.55 ORCL| 33.46 30.55 32.22 31.47 YHOO| 38.11 32.83 35.5 37.01 Function in by clause xbar frequently used to split data into time buckets sample use case : select maximum price for each sym for every hour/every half hour n xbar list is used for bucketing list of any q entity into n number of buckets q)select max price by 1 xbar time.hh from trades hh| price --| ----- 8 | 43.6 9 | 42.62 10| 43.06 11| 42.61 12| 42.57 13| 42.27 14| 42.03 15| 43.75 16| 44.02 q)select max price by 0.5 xbar time.hh from trades hh | price ---| ----- 4 | 43.6 4.5| 42.62 5 | 43.06 5.5| 42.61 6 | 42.57 6.5| 42.27 7 | 42.03 7.5| 43.75 8 | 44.02 q)select max price, sum size by sym, 5 xbar time.minute from trades sym minute| price size -----------| ------------ AAPL 08:00 | 25.44 559983 AAPL 08:05 | 25.41 658484 AAPL 08:10 | 25.45 568858 AAPL 08:15 | 25.05 590919 AAPL 08:20 | 24.97 592187 AAPL 08:25 | 25.18 618660 AAPL 08:30 | 24.94 536795 q) // not just for temporal data, xbar works on all types of q datatypes q)select sum size by sym, 5 xbar price from trades sym price| size ----------| -------- AAPL 20 | 2778333 AAPL 25 | 55483203 AAPL 30 | 1013213 CSCO 30 | 4698809 CSCO 35 | 53548364 DELL 25 | 39015640 DELL 30 | 19314582 GOOG 35 | 78225 GOOG 40 | 57698308 IBM 35 | 18314146 IBM 40 | 40631784 MSFT 35 | 52387686 MSFT 40 | 5763152 NOK 25 | 11650507 NOK 30 | 42933232 NOK 35 | 3316028 ORCL 30 | 58335324 YHOO 30 | 20237630 YHOO 35 | 39208545 tick direction example we want to add new column dir showing direction of price : +1 = increase in price, -1 = decrease in price, 0 = no change we define a function tradedirection q)tradedirection:{signum deltas x} q)tradedirection:{signum deltas x} q)update dir:tradedirection price by sym from trades time sym src price size dir ----------------------------------------------------- 2020.12.25D08:00:00.029000000 CSCO O 35.46 154 0 2020.12.25D08:00:00.229000000 NOK L 31.82 690 0 2020.12.25D08:00:00.250000000 YHOO L 35.5 1583 0 2020.12.25D08:00:00.861000000 GOOG N 41.41 3183 0 2020.12.25D08:00:00.946000000 IBM N 43.54 7605 0 2020.12.25D08:00:00.958000000 MSFT N 36.09 1592 0 2020.12.25D08:00:01.156000000 CSCO N 35.46 2144 0 2020.12.25D08:00:01.255000000 NOK O 31.78 508 -1 2020.12.25D08:00:01.272000000 MSFT L 36.09 4960 0 2020.12.25D08:00:01.527000000 NOK L 31.76 7832 -1 .. here we see for first row dir is 1 which is incorrect and should be 0 hence, we re-define our tradedirection function now we are using diadic form of deltas function q)tradedirection:{signum deltas[first x;x]} q)update dir:tradedirection price by sym from trades time sym src price size dir ----------------------------------------------------- 2020.12.25D08:00:00.029000000 CSCO O 35.46 154 0 2020.12.25D08:00:00.229000000 NOK L 31.82 690 0 2020.12.25D08:00:00.250000000 YHOO L 35.5 1583 0 2020.12.25D08:00:00.861000000 GOOG N 41.41 3183 0 2020.12.25D08:00:00.946000000 IBM N 43.54 7605 0 2020.12.25D08:00:00.958000000 MSFT N 36.09 1592 0 2020.12.25D08:00:01.156000000 CSCO N 35.46 2144 0 2020.12.25D08:00:01.255000000 NOK O 31.78 508 -1 2020.12.25D08:00:01.272000000 MSFT L 36.09 4960 0 2020.12.25D08:00:01.527000000 NOK L 31.76 7832 -1 .. now if we want to use dir column in grouping, to group by sym and upticks(dir=+1)/downticks(dir=-1)/no movement(dir=0) we do this by first updating dir in trades then group them by sym and dir q)select sum size by sym, dir from update dir:tradedirection price by sym from trades sym dir| size --------| -------- AAPL -1 | 23669600 AAPL 0 | 10796074 AAPL 1 | 24809075 CSCO -1 | 24273006 CSCO 0 | 10492199 CSCO 1 | 23481968 DELL -1 | 23765475 DELL 0 | 11081873 DELL 1 | 23482874 GOOG -1 | 23767777 .. we can also use fby in order to get same results in single statement q)select sum size by sym, dir:(tradedirection;price) fby sym from trades sym dir| size --------| -------- AAPL -1 | 23669600 AAPL 0 | 10796074 AAPL 1 | 24809075 CSCO -1 | 24273006 CSCO 0 | 10492199 CSCO 1 | 23481968 DELL -1 | 23765475 DELL 0 | 11081873 DELL 1 | 23482874 GOOG -1 | 23767777 .. same can be used for calculating a value which is dependent on another value in the group example : we want to know total size of trades for each sym where price is more than 10 tick moving average q)select sum size by sym, price>(mavg[10];price) fby sym from trades sym sym1| size ---------| -------- AAPL 0 | 29193756 AAPL 1 | 30080993 CSCO 0 | 29465592 CSCO 1 | 28781581 DELL 0 | 29500402 DELL 1 | 28829820 GOOG 0 | 28792193 GOOG 1 | 28984340 IBM 0 | 30403277 IBM 1 | 28542653 .. trades in size group Suppose we want to classify trades into 3 groups: size<1000 - small 1000<size<9000 - medium size>9000 - big we can do it using multiple selects have a function and apply fby in by clause q) // my attempt q)sizegroup:{?[x<1000;`small;?[x within 1000 8999; `medium;`big]]} q)select by sym, sg:(sizegroup;size) fby sym from trades sym sg | time src price size -----------| -------------------------------------------- AAPL big | 2020.12.25D16:22:11.344000000 N 30.05 9746 AAPL medium| 2020.12.25D16:29:54.842000000 O 29.87 1568 AAPL small | 2020.12.25D16:29:55.722000000 N 29.89 210 CSCO big | 2020.12.25D16:28:52.974000000 N 35.27 9805 CSCO medium| 2020.12.25D16:29:56.120000000 O 35.29 2803 CSCO small | 2020.12.25D16:29:53.908000000 L 35.38 906 DELL big | 2020.12.25D16:29:01.330000000 O 29.02 9338 DELL medium| 2020.12.25D16:29:57.739000000 N 28.66 1889 DELL small | 2020.12.25D16:29:41.032000000 O 28.69 386 GOOG big | 2020.12.25D16:28:03.979000000 O 44.02 9368 .. q) // instructor's attempt using bin q)sizegroup2:{`small`medium`big 0 1000 9000 bin x} q)select by sym, (sizegroup2;size) fby sym from trades sym sym1 | time src price size -----------| -------------------------------------------- AAPL big | 2020.12.25D12:47:22.215000000 L 25.27 9008 AAPL medium| 2020.12.25D16:29:14.600000000 L 25.48 1226 AAPL small | 2020.12.25D16:29:52.700000000 L 25.48 167 CSCO big | 2020.12.25D14:04:40.319000000 N 36.22 9027 CSCO medium| 2020.12.25D16:29:17.739000000 N 36.4 4333 CSCO small | 2020.12.25D16:28:08.296000000 N 36.46 815 DELL medium| 2020.12.25D16:27:11.848000000 O 29.81 4049 DELL small | 2020.12.25D16:22:44.943000000 N 29.82 39 GOOG medium| 2020.12.25D16:26:30.366000000 N 41.84 4956 GOOG small | 2020.12.25D16:23:11.310000000 N 41.8 264 IBM big | 2020.12.25D14:35:04.732000000 N 46.19 9051 IBM medium| 2020.12.25D16:28:57.502000000 O 46.89 1322 IBM small | 2020.12.25D16:22:03.114000000 N 47.04 796 MSFT big | 2020.12.25D16:22:42.020000000 N 35.59 9636 MSFT medium| 2020.12.25D16:14:50.382000000 N 35.59 1055 MSFT small | 2020.12.25D16:21:07.118000000 L 35.55 937 NOK big | 2020.12.25D10:29:07.054000000 L 31.16 9045 NOK medium| 2020.12.25D16:22:24.261000000 L 31.04 2457 NOK small | 2020.12.25D16:27:15.083000000 O 31.14 357 ORCL big | 2020.12.25D11:32:42.294000000 O 33.26 9812 .. q)// solution with bin needs size list to be sorted, solution with ? would work otherwise as well q)// performance comparison q) count trades`size 2000 q)sizegroup {?[x<1000;`small;?[x within 1000 8999; `medium;`big]]} q)\\t:10000 sizegroup trades`size 2069 q)\\t:10000 sizegroup trades`size 2083 q)sizegroup2 {`small`medium`big 0 1000 9000 bin x} q)\\t:10000 sizegroup2 trades`size 1675 q)\\t:10000 sizegroup2 trades`size 1677 q) // solution with bin is more optimized, faster by ~300-400ms, only restriction is list needs to be sorted, otherwise solution with ? would work in both cases sorted or otherwise","title":"By"},{"location":"kdb-q/Qsql/3_by_clause/#the-by-clause","text":"used to group data tables are set of lists q)/setup q)makedb[1000000;200000] tables[] q)`depth`quotes`trades we can apply group data using by without aggregation - aggregation function last is applied by default q)select by sym from trades sym | time src price size ----| -------------------------------------------- AAPL| 2020.12.25D16:29:55.722000000 N 29.89 210 CSCO| 2020.12.25D16:29:56.120000000 O 35.29 2803 DELL| 2020.12.25D16:29:57.739000000 N 28.66 1889 GOOG| 2020.12.25D16:29:56.958000000 N 43.87 1254 IBM | 2020.12.25D16:29:58.656000000 N 37.92 4379 MSFT| 2020.12.25D16:29:59.677000000 L 38.88 6493 NOK | 2020.12.25D16:29:57.448000000 N 34.55 1092 ORCL| 2020.12.25D16:29:57.487000000 L 31.47 2685 YHOO| 2020.12.25D16:29:59.662000000 N 37.01 5305 grouping with aggregation also works q)select max price, sum size by sym from trades sym | price size ----| -------------- AAPL| 30.39 59274749 CSCO| 38.11 58247173 DELL| 31.11 58330222 GOOG| 44.02 57776533 IBM | 43.6 58945930 MSFT| 41.2 58150838 NOK | 35.56 57899767 ORCL| 33.46 58335324 YHOO| 38.11 59446175 in case of grouping by 2 columns, they are grouped in order they are queried in example below, it's grouped first by sym and then again by src q)select max price, sum size by sym,src from trades sym src| price size --------| -------------- AAPL L | 30.36 20012403 AAPL N | 30.39 19782620 AAPL O | 30.33 19479726 CSCO L | 38.08 19537950 CSCO N | 38.11 19351658 CSCO O | 38.1 19357565 DELL L | 31.09 19188543 DELL N | 31.09 19677846 DELL O | 31.11 19463833 GOOG L | 44.02 19686298 GOOG N | 43.95 19884630 GOOG O | 44.02 18205605 IBM L | 43.55 19806381 IBM N | 43.54 19809111 IBM O | 43.6 19330438 MSFT L | 41.2 19272596 MSFT N | 41.17 19105562 MSFT O | 41.19 19772680 NOK L | 35.49 19366132 NOK N | 35.56 19586497 we can also get values without aggregation q)select max price, size by sym,src from trades sym src| price size .. --------| -------------------------------------------------------------------.. AAPL L | 30.36 1344 922 1223 9988 5087 4250 384 6328 3506 4901 1216 6507 236.. AAPL N | 30.39 119 7205 125 137 2385 6201 5277 781 434 778 5221 165 3665 697.. AAPL O | 30.33 1132 4958 4875 2746 1006 686 636 3929 4680 7888 8422 4246 268.. CSCO L | 38.08 36 3243 1037 2923 994 2832 1613 1530 452 1381 1334 9846 1676 .. CSCO N | 38.11 2144 1363 7463 5020 2068 1329 2075 4074 549 5471 812 7790 251.. CSCO O | 38.1 154 2171 797 1579 1868 2098 2910 1525 921 744 2132 6843 3296 .. DELL L | 31.09 4317 4648 27 5416 1379 3476 2331 154 1246 5158 558 5662 4337 .. DELL N | 31.09 2356 357 170 5101 460 2933 751 4031 1950 4837 5847 5596 244 1.. DELL O | 31.11 22 7472 376 440 2789 1247 520 3012 272 5445 6697 581 1201 108.. data is sorted by columns in ascending order of by clause in example below trades are first sorted ascending by time then by sym q)select max price by time, sym from trades time sym | price ----------------------------------| ----- 2020.12.25D08:00:00.029000000 CSCO| 35.46 2020.12.25D08:00:00.229000000 NOK | 31.82 2020.12.25D08:00:00.250000000 YHOO| 35.5 2020.12.25D08:00:00.861000000 GOOG| 41.41 2020.12.25D08:00:00.946000000 IBM | 43.54 2020.12.25D08:00:00.958000000 MSFT| 36.09 2020.12.25D08:00:01.156000000 CSCO| 35.46 2020.12.25D08:00:01.255000000 NOK | 31.78 2020.12.25D08:00:01.272000000 MSFT| 36.09 2020.12.25D08:00:01.527000000 NOK | 31.76 2020.12.25D08:00:01.546000000 AAPL| 25.36 2020.12.25D08:00:01.629000000 MSFT| 36.08 2020.12.25D08:00:01.680000000 YHOO| 35.54 2020.12.25D08:00:01.836000000 DELL| 29.07 2020.12.25D08:00:01.889000000 CSCO| 35.45 2020.12.25D08:00:02.127000000 DELL| 29.07 2020.12.25D08:00:02.161000000 YHOO| 35.5 2020.12.25D08:00:02.824000000 YHOO| 35.5 2020.12.25D08:00:03.191000000 YHOO| 35.52 2020.12.25D08:00:03.309000000 GOOG| 41.3","title":"The by clause"},{"location":"kdb-q/Qsql/3_by_clause/#hlocohlc","text":"high, low, open and close / open, high, low and close q)select high:max price, low:min price, open:first price, close:last price by sym from trades sym | high low open close ----| ----------------------- AAPL| 30.39 24.61 25.36 29.89 CSCO| 38.11 34.25 35.46 35.29 DELL| 31.11 28.48 29.07 28.66 GOOG| 44.02 39.9 41.41 43.87 IBM | 43.6 37.66 43.54 37.92 MSFT| 41.2 35.9 36.09 38.88 NOK | 35.56 29.09 31.82 34.55 ORCL| 33.46 30.55 32.22 31.47 YHOO| 38.11 32.83 35.5 37.01","title":"HLOC/OHLC"},{"location":"kdb-q/Qsql/3_by_clause/#function-in-by-clause","text":"","title":"Function in by clause"},{"location":"kdb-q/Qsql/3_by_clause/#xbar","text":"frequently used to split data into time buckets sample use case : select maximum price for each sym for every hour/every half hour n xbar list is used for bucketing list of any q entity into n number of buckets q)select max price by 1 xbar time.hh from trades hh| price --| ----- 8 | 43.6 9 | 42.62 10| 43.06 11| 42.61 12| 42.57 13| 42.27 14| 42.03 15| 43.75 16| 44.02 q)select max price by 0.5 xbar time.hh from trades hh | price ---| ----- 4 | 43.6 4.5| 42.62 5 | 43.06 5.5| 42.61 6 | 42.57 6.5| 42.27 7 | 42.03 7.5| 43.75 8 | 44.02 q)select max price, sum size by sym, 5 xbar time.minute from trades sym minute| price size -----------| ------------ AAPL 08:00 | 25.44 559983 AAPL 08:05 | 25.41 658484 AAPL 08:10 | 25.45 568858 AAPL 08:15 | 25.05 590919 AAPL 08:20 | 24.97 592187 AAPL 08:25 | 25.18 618660 AAPL 08:30 | 24.94 536795 q) // not just for temporal data, xbar works on all types of q datatypes q)select sum size by sym, 5 xbar price from trades sym price| size ----------| -------- AAPL 20 | 2778333 AAPL 25 | 55483203 AAPL 30 | 1013213 CSCO 30 | 4698809 CSCO 35 | 53548364 DELL 25 | 39015640 DELL 30 | 19314582 GOOG 35 | 78225 GOOG 40 | 57698308 IBM 35 | 18314146 IBM 40 | 40631784 MSFT 35 | 52387686 MSFT 40 | 5763152 NOK 25 | 11650507 NOK 30 | 42933232 NOK 35 | 3316028 ORCL 30 | 58335324 YHOO 30 | 20237630 YHOO 35 | 39208545","title":"xbar"},{"location":"kdb-q/Qsql/3_by_clause/#tick-direction-example","text":"we want to add new column dir showing direction of price : +1 = increase in price, -1 = decrease in price, 0 = no change we define a function tradedirection q)tradedirection:{signum deltas x} q)tradedirection:{signum deltas x} q)update dir:tradedirection price by sym from trades time sym src price size dir ----------------------------------------------------- 2020.12.25D08:00:00.029000000 CSCO O 35.46 154 0 2020.12.25D08:00:00.229000000 NOK L 31.82 690 0 2020.12.25D08:00:00.250000000 YHOO L 35.5 1583 0 2020.12.25D08:00:00.861000000 GOOG N 41.41 3183 0 2020.12.25D08:00:00.946000000 IBM N 43.54 7605 0 2020.12.25D08:00:00.958000000 MSFT N 36.09 1592 0 2020.12.25D08:00:01.156000000 CSCO N 35.46 2144 0 2020.12.25D08:00:01.255000000 NOK O 31.78 508 -1 2020.12.25D08:00:01.272000000 MSFT L 36.09 4960 0 2020.12.25D08:00:01.527000000 NOK L 31.76 7832 -1 .. here we see for first row dir is 1 which is incorrect and should be 0 hence, we re-define our tradedirection function now we are using diadic form of deltas function q)tradedirection:{signum deltas[first x;x]} q)update dir:tradedirection price by sym from trades time sym src price size dir ----------------------------------------------------- 2020.12.25D08:00:00.029000000 CSCO O 35.46 154 0 2020.12.25D08:00:00.229000000 NOK L 31.82 690 0 2020.12.25D08:00:00.250000000 YHOO L 35.5 1583 0 2020.12.25D08:00:00.861000000 GOOG N 41.41 3183 0 2020.12.25D08:00:00.946000000 IBM N 43.54 7605 0 2020.12.25D08:00:00.958000000 MSFT N 36.09 1592 0 2020.12.25D08:00:01.156000000 CSCO N 35.46 2144 0 2020.12.25D08:00:01.255000000 NOK O 31.78 508 -1 2020.12.25D08:00:01.272000000 MSFT L 36.09 4960 0 2020.12.25D08:00:01.527000000 NOK L 31.76 7832 -1 .. now if we want to use dir column in grouping, to group by sym and upticks(dir=+1)/downticks(dir=-1)/no movement(dir=0) we do this by first updating dir in trades then group them by sym and dir q)select sum size by sym, dir from update dir:tradedirection price by sym from trades sym dir| size --------| -------- AAPL -1 | 23669600 AAPL 0 | 10796074 AAPL 1 | 24809075 CSCO -1 | 24273006 CSCO 0 | 10492199 CSCO 1 | 23481968 DELL -1 | 23765475 DELL 0 | 11081873 DELL 1 | 23482874 GOOG -1 | 23767777 .. we can also use fby in order to get same results in single statement q)select sum size by sym, dir:(tradedirection;price) fby sym from trades sym dir| size --------| -------- AAPL -1 | 23669600 AAPL 0 | 10796074 AAPL 1 | 24809075 CSCO -1 | 24273006 CSCO 0 | 10492199 CSCO 1 | 23481968 DELL -1 | 23765475 DELL 0 | 11081873 DELL 1 | 23482874 GOOG -1 | 23767777 .. same can be used for calculating a value which is dependent on another value in the group example : we want to know total size of trades for each sym where price is more than 10 tick moving average q)select sum size by sym, price>(mavg[10];price) fby sym from trades sym sym1| size ---------| -------- AAPL 0 | 29193756 AAPL 1 | 30080993 CSCO 0 | 29465592 CSCO 1 | 28781581 DELL 0 | 29500402 DELL 1 | 28829820 GOOG 0 | 28792193 GOOG 1 | 28984340 IBM 0 | 30403277 IBM 1 | 28542653 ..","title":"tick direction example"},{"location":"kdb-q/Qsql/3_by_clause/#trades-in-size-group","text":"Suppose we want to classify trades into 3 groups: size<1000 - small 1000<size<9000 - medium size>9000 - big we can do it using multiple selects have a function and apply fby in by clause q) // my attempt q)sizegroup:{?[x<1000;`small;?[x within 1000 8999; `medium;`big]]} q)select by sym, sg:(sizegroup;size) fby sym from trades sym sg | time src price size -----------| -------------------------------------------- AAPL big | 2020.12.25D16:22:11.344000000 N 30.05 9746 AAPL medium| 2020.12.25D16:29:54.842000000 O 29.87 1568 AAPL small | 2020.12.25D16:29:55.722000000 N 29.89 210 CSCO big | 2020.12.25D16:28:52.974000000 N 35.27 9805 CSCO medium| 2020.12.25D16:29:56.120000000 O 35.29 2803 CSCO small | 2020.12.25D16:29:53.908000000 L 35.38 906 DELL big | 2020.12.25D16:29:01.330000000 O 29.02 9338 DELL medium| 2020.12.25D16:29:57.739000000 N 28.66 1889 DELL small | 2020.12.25D16:29:41.032000000 O 28.69 386 GOOG big | 2020.12.25D16:28:03.979000000 O 44.02 9368 .. q) // instructor's attempt using bin q)sizegroup2:{`small`medium`big 0 1000 9000 bin x} q)select by sym, (sizegroup2;size) fby sym from trades sym sym1 | time src price size -----------| -------------------------------------------- AAPL big | 2020.12.25D12:47:22.215000000 L 25.27 9008 AAPL medium| 2020.12.25D16:29:14.600000000 L 25.48 1226 AAPL small | 2020.12.25D16:29:52.700000000 L 25.48 167 CSCO big | 2020.12.25D14:04:40.319000000 N 36.22 9027 CSCO medium| 2020.12.25D16:29:17.739000000 N 36.4 4333 CSCO small | 2020.12.25D16:28:08.296000000 N 36.46 815 DELL medium| 2020.12.25D16:27:11.848000000 O 29.81 4049 DELL small | 2020.12.25D16:22:44.943000000 N 29.82 39 GOOG medium| 2020.12.25D16:26:30.366000000 N 41.84 4956 GOOG small | 2020.12.25D16:23:11.310000000 N 41.8 264 IBM big | 2020.12.25D14:35:04.732000000 N 46.19 9051 IBM medium| 2020.12.25D16:28:57.502000000 O 46.89 1322 IBM small | 2020.12.25D16:22:03.114000000 N 47.04 796 MSFT big | 2020.12.25D16:22:42.020000000 N 35.59 9636 MSFT medium| 2020.12.25D16:14:50.382000000 N 35.59 1055 MSFT small | 2020.12.25D16:21:07.118000000 L 35.55 937 NOK big | 2020.12.25D10:29:07.054000000 L 31.16 9045 NOK medium| 2020.12.25D16:22:24.261000000 L 31.04 2457 NOK small | 2020.12.25D16:27:15.083000000 O 31.14 357 ORCL big | 2020.12.25D11:32:42.294000000 O 33.26 9812 .. q)// solution with bin needs size list to be sorted, solution with ? would work otherwise as well q)// performance comparison q) count trades`size 2000 q)sizegroup {?[x<1000;`small;?[x within 1000 8999; `medium;`big]]} q)\\t:10000 sizegroup trades`size 2069 q)\\t:10000 sizegroup trades`size 2083 q)sizegroup2 {`small`medium`big 0 1000 9000 bin x} q)\\t:10000 sizegroup2 trades`size 1675 q)\\t:10000 sizegroup2 trades`size 1677 q) // solution with bin is more optimized, faster by ~300-400ms, only restriction is list needs to be sorted, otherwise solution with ? would work in both cases sorted or otherwise","title":"trades in size group"},{"location":"kdb-q/Qsql/4_functional_form/","text":"Functional Form functional form is used for select, update, delete and exec queries q)//setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[100000;1000] q)tables[] `depth`quotes`trades select general format for select is ?[table name; where clause; groupings; aggregations] we can also get each component of functional query using function parse q)parse\"select from trades\" ? `trades () 0b () q)?[`trades;();0b;()] time sym src price size ------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 2020.12.25D08:01:14.926000000 NOK L 31.7 702 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 .. if our select query is bit complex then understanding output of parse function is bit difficult, , means enlist keys of aggregation or groupings dictionary are names we want our columns to be and values are values we want columns to hold q)select ssize:sum size by sym from trades where price<35 sym | ssize ----| ------ AAPL| 287593 CSCO| 9816 DELL| 296884 NOK | 325169 ORCL| 255399 YHOO| 91038 q)parse\"select ssize:sum size by sym from trades where price<35\" ? `trades ,,(<;`price;35) (,`sym)!,`sym (,`ssize)!,(sum;`size) q)?[trades;enlist(<;`price;35f);(enlist `sym)!enlist `sym;(enlist `ssize)!(enlist(sum;`size))] sym | ssize ----| ------ AAPL| 287593 CSCO| 9816 DELL| 296884 NOK | 325169 ORCL| 255399 YHOO| 91038 functional forms are generally used when we functions to be evaluate queries on dynamically passed column names functional forms are hard to read, difficult to write, needs atoms to be enlisted and thus should only be used when necessary exec it is simplified version of select for no group by we use empty list () than 0b general form : ?[tablename; where clause; groupings; aggregations] exec sym from table = ?[table;();(); sym]` q)exec sym from trades `g#`MSFT`IBM`NOK`AAPL`GOOG`CSCO`NOK`AAPL`NOK`YHOO`AAPL`AAPL`AAPL`IBM`CSCO`YHO.. q)parse\"exec sym from trades\" ? `trades () () ,`sym q)?[trades;();();`sym] `g#`MSFT`IBM`NOK`AAPL`GOOG`CSCO`NOK`AAPL`NOK`YHOO`AAPL`AAPL`AAPL`IBM`CSCO`YHO.. update it is very much similar to select, we use ! rather than ? general form : ![tablename;where clause; groupings; aggregations] q)update pp:price*2 from trades time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 .. q)parse\"update pp:price*2 from trades\" ! `trades () 0b (,`pp)!,(*;`price;2) q)![trades;();0b;(enlist `pp)!enlist(*;`price;2)] time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 .. q)![trades;();0b;((),`pp)!enlist (*;`price;2)] time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 .. delete it is very much similar to exec , here ! is used instead of ? general form : ![tablename;where clause; groupings; aggregations] q)delete price from trades time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. q)parse\"delete price from trades\" ! `trades () 0b ,,`price q)![trades;();0b;(),`price] time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. in update and delete if we want changes to happen in place(directly on table) - we pass tablename as symbol q)![`trades;();0b;(),`price] // in-place change as tablename is passed as symbol `trades q)trades time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. in delete we can only specify where conditions or aggregations but not both at the same time q)delete price from trades where sym=`AAPL 'nyi q)parse\"delete price from trades where sym=`AAPL\" ! `trades ,,(=;`sym;,`AAPL) 0b ,,`price q)![`trades;enlist(=;`sym;enlist `AAPL);0b;(),`price] 'nyi","title":"Functional Form"},{"location":"kdb-q/Qsql/4_functional_form/#functional-form","text":"functional form is used for select, update, delete and exec queries q)//setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[100000;1000] q)tables[] `depth`quotes`trades","title":"Functional Form"},{"location":"kdb-q/Qsql/4_functional_form/#select","text":"general format for select is ?[table name; where clause; groupings; aggregations] we can also get each component of functional query using function parse q)parse\"select from trades\" ? `trades () 0b () q)?[`trades;();0b;()] time sym src price size ------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 2020.12.25D08:01:14.926000000 NOK L 31.7 702 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 .. if our select query is bit complex then understanding output of parse function is bit difficult, , means enlist keys of aggregation or groupings dictionary are names we want our columns to be and values are values we want columns to hold q)select ssize:sum size by sym from trades where price<35 sym | ssize ----| ------ AAPL| 287593 CSCO| 9816 DELL| 296884 NOK | 325169 ORCL| 255399 YHOO| 91038 q)parse\"select ssize:sum size by sym from trades where price<35\" ? `trades ,,(<;`price;35) (,`sym)!,`sym (,`ssize)!,(sum;`size) q)?[trades;enlist(<;`price;35f);(enlist `sym)!enlist `sym;(enlist `ssize)!(enlist(sum;`size))] sym | ssize ----| ------ AAPL| 287593 CSCO| 9816 DELL| 296884 NOK | 325169 ORCL| 255399 YHOO| 91038 functional forms are generally used when we functions to be evaluate queries on dynamically passed column names functional forms are hard to read, difficult to write, needs atoms to be enlisted and thus should only be used when necessary","title":"select"},{"location":"kdb-q/Qsql/4_functional_form/#exec","text":"it is simplified version of select for no group by we use empty list () than 0b general form : ?[tablename; where clause; groupings; aggregations] exec sym from table = ?[table;();(); sym]` q)exec sym from trades `g#`MSFT`IBM`NOK`AAPL`GOOG`CSCO`NOK`AAPL`NOK`YHOO`AAPL`AAPL`AAPL`IBM`CSCO`YHO.. q)parse\"exec sym from trades\" ? `trades () () ,`sym q)?[trades;();();`sym] `g#`MSFT`IBM`NOK`AAPL`GOOG`CSCO`NOK`AAPL`NOK`YHOO`AAPL`AAPL`AAPL`IBM`CSCO`YHO..","title":"exec"},{"location":"kdb-q/Qsql/4_functional_form/#update","text":"it is very much similar to select, we use ! rather than ? general form : ![tablename;where clause; groupings; aggregations] q)update pp:price*2 from trades time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 .. q)parse\"update pp:price*2 from trades\" ! `trades () 0b (,`pp)!,(*;`price;2) q)![trades;();0b;(enlist `pp)!enlist(*;`price;2)] time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 .. q)![trades;();0b;((),`pp)!enlist (*;`price;2)] time sym src price size pp ------------------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 36.07 3996 72.14 2020.12.25D08:00:43.092000000 IBM N 43.59 3001 87.18 2020.12.25D08:01:14.926000000 NOK L 31.7 702 63.4 2020.12.25D08:01:26.622000000 AAPL N 25.3 1228 50.6 2020.12.25D08:01:27.019000000 GOOG L 41.38 4905 82.76 ..","title":"update"},{"location":"kdb-q/Qsql/4_functional_form/#delete","text":"it is very much similar to exec , here ! is used instead of ? general form : ![tablename;where clause; groupings; aggregations] q)delete price from trades time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. q)parse\"delete price from trades\" ! `trades () 0b ,,`price q)![trades;();0b;(),`price] time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. in update and delete if we want changes to happen in place(directly on table) - we pass tablename as symbol q)![`trades;();0b;(),`price] // in-place change as tablename is passed as symbol `trades q)trades time sym src size ------------------------------------------- 2020.12.25D08:00:06.782000000 MSFT N 3996 2020.12.25D08:00:43.092000000 IBM N 3001 2020.12.25D08:01:14.926000000 NOK L 702 2020.12.25D08:01:26.622000000 AAPL N 1228 2020.12.25D08:01:27.019000000 GOOG L 4905 .. in delete we can only specify where conditions or aggregations but not both at the same time q)delete price from trades where sym=`AAPL 'nyi q)parse\"delete price from trades where sym=`AAPL\" ! `trades ,,(=;`sym;,`AAPL) 0b ,,`price q)![`trades;enlist(=;`sym;enlist `AAPL);0b;(),`price] 'nyi","title":"delete"},{"location":"kdb-q/atom-lists/atom/","text":"Atoms q has 3 main entities: atom , list and dictionary Atom is smallest level of entity all others are combinations of atoms Basic data types boolean short int long float character symbol We can specify types while defining variables in q q) a:1 q) a:1i / here we are specifying type of variable a to be int q) c:1 / if we don't specify, q automatically assigns, here c is of type long q) d:2.0 q) b:2f / b and d are float type q) t:1b / boolean type is specified by b, its 1b or 0b q) d:\"m\" / d is now character q) str:\"mogli\" / str is not atom, its a list of 5 characters q) sym: `mogli / sym is symbol, its a data type in q where we can store list of characters as atom Type - we can check type of a variable/constant using function type , - means atom, + /no sign means list Reference q) type d / d is atom of type character, -ve sign in type -10h q) type str / str is a list of 5 characters, +ve sign in type 10h q) type sym / symbol is an atom -11h Temporal data types date - yyyy.mm.dd month - yyyy.mm m time - hh:mm:ss.12345689 - precision till nanoseconds timestamp - yyyy.mm.ddDhh:mm:ss.123456789 - precision till nanoseconds we need not specify full precision for timestamp date + time = timestamp date and time are seprated by D datetime - yyyy.mm.ddThh:mm:ss.123 - precision till milliseconds (used previously, avoid using now) date and time are seprated by T Arithmetic operations can be performed with temporal data types Dates and time are based at 0 and saved as numerals in q date 0 is 2000.01.01 , before - , later + time 0 is midnight - 00:00:00.000000000 timestamp 0 is midnight of 2000.01.01 - 2000.01.01D00:00:00.000000000 , before - , later + Current date: .z.d , current time: .z.t , current timestamp: .z.p q) time: 09:00:00.000000000 q) type time -16h q) date: 2020.05.30 q) type date -14h q) month: 2020.05m / month is defined by putting 'm' in the end,'m' helps to differentiate between float and month q) timestamp: 2019.05.30D17:15:00.000000000 q) t:2019.05.30D / time stamp precision can be relaxed while defining q) t 2020.05.30D00:00:00.000000000 q) date+time 2020.05.30D09:00:00.000000000 q) date-2000.01.01 7455i Match ~ vs. equal = match compare whole object including type, equal compare underlying values q) 3i=3i 1b q) 3i=3f 1b q) 3i~3i 1b q) 3i~3f 0b Type promotion Arithmetic operations can result into type promotion Default type for integer is long(64 bit integer) Boolean are promoted to another type when needed this is useful in if or other conditional statements : if[test_condition; do...]; non-zero(+/-) is true 1b , 0 is false 0b q) 2i+3h 5i q) type 1i+4.3f -9h q) a:1 / default type of variable 'a' would be long q) type a -7h q) a=1 1b q) if[a=1; show \"a equals 1\"] / here it is evaluating a=1 and proceed further if true \"a equals 1\" q) if[a; show \"statement not false\"] / here it is checking a is non zero \"statement not false\" q) if[0; show \"false\"] q) if[count (1 2 3); show \"list not empty\"] \"list not empty\" q) if[count (); show \"list is empty\"] q) Casting new_type $ old_type from string to other types, we need to use corresponding character for new_type from other types to string, we use function string numerals to symbol casting dont work directly, first we need to cast to string casting temporal values to numerals we can see their underlying values q) `int$3.1f 3i q) `int$3.6f 4i / rounded off q) `$\"name\" `name / from string to symbol use empty symbol ` q) string `test \"test\" q) string 23i \"23\" q) \"I\"$\"23\" 23i q) \"F\"$\"23\" 23f q) `$2020.05.30 'type q) `$string 2020.05.30 `2020.05.30 q) date-2000.01.01 7455i q) `int$date 7455i q) 0=2000.01.01 1b","title":"Atoms"},{"location":"kdb-q/atom-lists/atom/#atoms","text":"q has 3 main entities: atom , list and dictionary Atom is smallest level of entity all others are combinations of atoms","title":"Atoms"},{"location":"kdb-q/atom-lists/atom/#basic-data-types","text":"boolean short int long float character symbol We can specify types while defining variables in q q) a:1 q) a:1i / here we are specifying type of variable a to be int q) c:1 / if we don't specify, q automatically assigns, here c is of type long q) d:2.0 q) b:2f / b and d are float type q) t:1b / boolean type is specified by b, its 1b or 0b q) d:\"m\" / d is now character q) str:\"mogli\" / str is not atom, its a list of 5 characters q) sym: `mogli / sym is symbol, its a data type in q where we can store list of characters as atom Type - we can check type of a variable/constant using function type , - means atom, + /no sign means list Reference q) type d / d is atom of type character, -ve sign in type -10h q) type str / str is a list of 5 characters, +ve sign in type 10h q) type sym / symbol is an atom -11h","title":"Basic data types"},{"location":"kdb-q/atom-lists/atom/#temporal-data-types","text":"date - yyyy.mm.dd month - yyyy.mm m time - hh:mm:ss.12345689 - precision till nanoseconds timestamp - yyyy.mm.ddDhh:mm:ss.123456789 - precision till nanoseconds we need not specify full precision for timestamp date + time = timestamp date and time are seprated by D datetime - yyyy.mm.ddThh:mm:ss.123 - precision till milliseconds (used previously, avoid using now) date and time are seprated by T Arithmetic operations can be performed with temporal data types Dates and time are based at 0 and saved as numerals in q date 0 is 2000.01.01 , before - , later + time 0 is midnight - 00:00:00.000000000 timestamp 0 is midnight of 2000.01.01 - 2000.01.01D00:00:00.000000000 , before - , later + Current date: .z.d , current time: .z.t , current timestamp: .z.p q) time: 09:00:00.000000000 q) type time -16h q) date: 2020.05.30 q) type date -14h q) month: 2020.05m / month is defined by putting 'm' in the end,'m' helps to differentiate between float and month q) timestamp: 2019.05.30D17:15:00.000000000 q) t:2019.05.30D / time stamp precision can be relaxed while defining q) t 2020.05.30D00:00:00.000000000 q) date+time 2020.05.30D09:00:00.000000000 q) date-2000.01.01 7455i","title":"Temporal data types"},{"location":"kdb-q/atom-lists/atom/#match-vs-equal","text":"match compare whole object including type, equal compare underlying values q) 3i=3i 1b q) 3i=3f 1b q) 3i~3i 1b q) 3i~3f 0b","title":"Match ~ vs. equal ="},{"location":"kdb-q/atom-lists/atom/#type-promotion","text":"Arithmetic operations can result into type promotion Default type for integer is long(64 bit integer) Boolean are promoted to another type when needed this is useful in if or other conditional statements : if[test_condition; do...]; non-zero(+/-) is true 1b , 0 is false 0b q) 2i+3h 5i q) type 1i+4.3f -9h q) a:1 / default type of variable 'a' would be long q) type a -7h q) a=1 1b q) if[a=1; show \"a equals 1\"] / here it is evaluating a=1 and proceed further if true \"a equals 1\" q) if[a; show \"statement not false\"] / here it is checking a is non zero \"statement not false\" q) if[0; show \"false\"] q) if[count (1 2 3); show \"list not empty\"] \"list not empty\" q) if[count (); show \"list is empty\"] q)","title":"Type promotion"},{"location":"kdb-q/atom-lists/atom/#casting","text":"new_type $ old_type from string to other types, we need to use corresponding character for new_type from other types to string, we use function string numerals to symbol casting dont work directly, first we need to cast to string casting temporal values to numerals we can see their underlying values q) `int$3.1f 3i q) `int$3.6f 4i / rounded off q) `$\"name\" `name / from string to symbol use empty symbol ` q) string `test \"test\" q) string 23i \"23\" q) \"I\"$\"23\" 23i q) \"F\"$\"23\" 23f q) `$2020.05.30 'type q) `$string 2020.05.30 `2020.05.30 q) date-2000.01.01 7455i q) `int$date 7455i q) 0=2000.01.01 1b","title":"Casting"},{"location":"kdb-q/atom-lists/basic_operations/","text":"Basic Operations Mathematical Operations Add q)2+6 8 Subtract q)10-5 5 Divide % is used instead of / , as / is used for comment q)10%2 5f / f means float Multiply q)2*7 14 Order of operation q follows right to left order instead of BODMAS q)5*2+3 / 3+2=5*5=25 25 Order can be forced using brackets q)(5*2)+3 13 Assignment any entity(atom/function/list/table) in q can be assigned to a variable using operator : q)a:5 q)b:6 / values are not displayed in next line as before, they are stored(assigned) q)c:7 q)d:a+b+c q)d / to display value, enter variable name 18 Comparison or Logical operators Two numbers/entities can be compared using : < less than > greater than <= less than or equal to >= greater than or equal to = equal to - only checks underlying value <> not equal to ~ match - checks underlying value and type q)a<b 1b q)d<>a 1b q)c<b 0b / 1b stand for true, 0b for false q)5.0=5 1b q)5.0~5 0b Compound and Multiple Assignment Compound Assignment q)x:10 q)x:x+2 / add 2 to x and store the result in x q)x 12 q)x+:2 / add 2 to x q)x 14 Multiple Assignment q)a:2 q)c:7*b:2+a / multiple variables are assigned in same statement q)a 2 q)b 4 q)c 28 q)\\v / to view all variables defined till now \\v `a`b`c`x Exit q q)\\\\ / double black slash","title":"Basic Operations"},{"location":"kdb-q/atom-lists/basic_operations/#basic-operations","text":"","title":"Basic Operations"},{"location":"kdb-q/atom-lists/basic_operations/#mathematical-operations","text":"","title":"Mathematical Operations"},{"location":"kdb-q/atom-lists/basic_operations/#add","text":"q)2+6 8","title":"Add"},{"location":"kdb-q/atom-lists/basic_operations/#subtract","text":"q)10-5 5","title":"Subtract"},{"location":"kdb-q/atom-lists/basic_operations/#divide","text":"% is used instead of / , as / is used for comment q)10%2 5f / f means float","title":"Divide"},{"location":"kdb-q/atom-lists/basic_operations/#multiply","text":"q)2*7 14","title":"Multiply"},{"location":"kdb-q/atom-lists/basic_operations/#order-of-operation","text":"q follows right to left order instead of BODMAS q)5*2+3 / 3+2=5*5=25 25 Order can be forced using brackets q)(5*2)+3 13","title":"Order of operation"},{"location":"kdb-q/atom-lists/basic_operations/#assignment","text":"any entity(atom/function/list/table) in q can be assigned to a variable using operator : q)a:5 q)b:6 / values are not displayed in next line as before, they are stored(assigned) q)c:7 q)d:a+b+c q)d / to display value, enter variable name 18","title":"Assignment"},{"location":"kdb-q/atom-lists/basic_operations/#comparison-or-logical-operators","text":"Two numbers/entities can be compared using : < less than > greater than <= less than or equal to >= greater than or equal to = equal to - only checks underlying value <> not equal to ~ match - checks underlying value and type q)a<b 1b q)d<>a 1b q)c<b 0b / 1b stand for true, 0b for false q)5.0=5 1b q)5.0~5 0b","title":"Comparison or Logical operators"},{"location":"kdb-q/atom-lists/basic_operations/#compound-and-multiple-assignment","text":"","title":"Compound and Multiple Assignment"},{"location":"kdb-q/atom-lists/basic_operations/#compound-assignment","text":"q)x:10 q)x:x+2 / add 2 to x and store the result in x q)x 12 q)x+:2 / add 2 to x q)x 14","title":"Compound Assignment"},{"location":"kdb-q/atom-lists/basic_operations/#multiple-assignment","text":"q)a:2 q)c:7*b:2+a / multiple variables are assigned in same statement q)a 2 q)b 4 q)c 28 q)\\v / to view all variables defined till now \\v `a`b`c`x","title":"Multiple Assignment"},{"location":"kdb-q/atom-lists/basic_operations/#exit-q","text":"q)\\\\ / double black slash","title":"Exit q"},{"location":"kdb-q/atom-lists/hints_and_tricks/","text":"Hints and Tricks Time of expression \\t is used to see runtime of an expression in milliseconds \\t:n this is used when we want to run same expression n times for sum of two large lists/array, q is quite fast because of vector calculation. In other languages its iterative method to go to each element of both lists then add, in vector calculation operation is performed simultaneously on every element of lists help.q This script can be put in QHOME directory and loaded in q.q \\l help.q , thus when q sessions opens q.q is called and help.q will be loaded It acts like man page for q, providing info for most of the cases required in daily use q)help` attributes| data attributes cmdline | command line parameters data | data types debug | debug - debugger commands define | assign, define, control and debug doth | .h namespace: markup dotj | .j namespace: JSON dotq | .Q namespace: utilities dotz | .z namespace: system information and callbacks envvar | envvar - environment variables errors | error messages internal | negative bang - -n!x - internal system calls iterator | iterators (formerly adverbs) keyword | keywords (functions) kill | kill - killing a q session lic | licenses - kdb+ license files operator | operators (functions) save | save/load tables syscmd | system commands temporal | temporal - date & time casts providing key in will show all existing options q)help`cmdline q [f] [-b] [-c r c] [-C r c] [-g 0|1] [-l] [-L][-o N] [-p N] [-P N] [-q] [-r :H:P] [-s N] [-t N] [-T N] [-u|U F] [-w N] [-W N] [-z 0|1] f load script (*.q, *.k, *.s), file or directory -b block client write access -c r c console maxRows maxCols -C r c http display maxRows maxCols -e [0|1|2] disable|enable|display error trap clients -g [0|1] disable|enable immediate garbage collect, default 0 -l log updates to filesystem -L as -l, but sync logging -o N offset hours (from GMT: affects .z.Z/T/P/N), default 0 -p N port kdbc(/jdbc/odbc) http(html xml txt csv) -p -N port multithreaded kdbc -P N printdigits, default 7, 0=>all -q quiet, no startup banner text -r :H:P replicate from :host:port -s N slaves for parallel execution -S N set random seed -t N timer milliseconds, default 0 (=> none) -T N timeout seconds(applies to all client queries), default 0 (=> none) -u F usr:pwd file, no access above start directory -u [0|1] enable|disable system escapes -U F as -u, but no file restrictions -w N workspace MB limit (default: 2*RAM) -W N week offset, default 2, 0=>saturday -z [0|1] \"D\" uses 0:mm/dd/yyyy or 1:dd/mm/yyyy, default 0 Helps to reduce time in opening up ref page of kdb","title":"Hints and Tricks"},{"location":"kdb-q/atom-lists/hints_and_tricks/#hints-and-tricks","text":"","title":"Hints and Tricks"},{"location":"kdb-q/atom-lists/hints_and_tricks/#time-of-expression","text":"\\t is used to see runtime of an expression in milliseconds \\t:n this is used when we want to run same expression n times for sum of two large lists/array, q is quite fast because of vector calculation. In other languages its iterative method to go to each element of both lists then add, in vector calculation operation is performed simultaneously on every element of lists","title":"Time of expression"},{"location":"kdb-q/atom-lists/hints_and_tricks/#helpq","text":"This script can be put in QHOME directory and loaded in q.q \\l help.q , thus when q sessions opens q.q is called and help.q will be loaded It acts like man page for q, providing info for most of the cases required in daily use q)help` attributes| data attributes cmdline | command line parameters data | data types debug | debug - debugger commands define | assign, define, control and debug doth | .h namespace: markup dotj | .j namespace: JSON dotq | .Q namespace: utilities dotz | .z namespace: system information and callbacks envvar | envvar - environment variables errors | error messages internal | negative bang - -n!x - internal system calls iterator | iterators (formerly adverbs) keyword | keywords (functions) kill | kill - killing a q session lic | licenses - kdb+ license files operator | operators (functions) save | save/load tables syscmd | system commands temporal | temporal - date & time casts providing key in will show all existing options q)help`cmdline q [f] [-b] [-c r c] [-C r c] [-g 0|1] [-l] [-L][-o N] [-p N] [-P N] [-q] [-r :H:P] [-s N] [-t N] [-T N] [-u|U F] [-w N] [-W N] [-z 0|1] f load script (*.q, *.k, *.s), file or directory -b block client write access -c r c console maxRows maxCols -C r c http display maxRows maxCols -e [0|1|2] disable|enable|display error trap clients -g [0|1] disable|enable immediate garbage collect, default 0 -l log updates to filesystem -L as -l, but sync logging -o N offset hours (from GMT: affects .z.Z/T/P/N), default 0 -p N port kdbc(/jdbc/odbc) http(html xml txt csv) -p -N port multithreaded kdbc -P N printdigits, default 7, 0=>all -q quiet, no startup banner text -r :H:P replicate from :host:port -s N slaves for parallel execution -S N set random seed -t N timer milliseconds, default 0 (=> none) -T N timeout seconds(applies to all client queries), default 0 (=> none) -u F usr:pwd file, no access above start directory -u [0|1] enable|disable system escapes -U F as -u, but no file restrictions -w N workspace MB limit (default: 2*RAM) -W N week offset, default 2, 0=>saturday -z [0|1] \"D\" uses 0:mm/dd/yyyy or 1:dd/mm/yyyy, default 0 Helps to reduce time in opening up ref page of kdb","title":"help.q"},{"location":"kdb-q/atom-lists/introduction_to_lists/","text":"Introduction to lists list is 2nd data structure in q, 1st is atom can be defined for all data types q) l: 1 2 3 4 / default type is float q) type l 7h / + means list, 7 means list of floats q) s:`q`w`e`r`t`y q) type s 11h / list of symbols useful function to creating list is til ** til n returns list of long integers starting from 0 and ending with n-1 q) l2: til 5 q) l2 0 1 2 3 4 Arithmetic and logical operations on lists arithmetic and logical operation work atom by atom in a list q) l2+10 10 11 12 13 14 / 10 is added to all atoms of list q) l2:+5 / compound assignment to make changes in place q) 5 6 7 8 9 q) l2<7 11000b / returns boolean list, 1b at indexes where expression is true, this is also evaluated atom by atom Types of lists Simple list atoms in the list are of same types example: lists created by til q) l: til 4 q) l 0 1 2 3 q) type l 7h q) type each l -7 -7 -7 -7h Empty list can be created using () with no type can also be forced to typed q) l3:() q) type l3 0h q) l4:`int$() q) type l4 6h Mixed list contains entities[atoms, lists, etc.] of different types q) l5: (`q;23i;9.8f;\"hello\") q) l5 `q 23i 9.8000000000000007 \"hello\" q) type l5 0h q) type each l5 -11 -6 -9 10h equal = vs match ~ q) l6: 1 2 3 4i q) l7: 1 2 3 4f q) l6=l7 / checks underlying values 1111b q) l6~l7 / checks types as well 0b Singleton list if we try to assign 1 item to a variable, it will be an atom we use function enlist to make singleton list: list with single item q) l8:99 q) type l8 -7h / -ve sign means atom q) l8: enlist 99 q) type l8 7h / +ve sign means list q) type each l8 ,-7h q) l8 ,99 q) ```` ## Indexing and index assignment * indexing in list is done using `[]` - list`[`index/es`]` * indexes starts from `0` and ends with length_of_list-1 * in `[]` we can provide 1 index or list of indexes ```q q) l9: (1 2; 30 40 50; 77 88; -10 -11) q) l9 1 2 30 40 50 77 88 -10 -11 q) l9[0] 1 2 q) l9[3] -10 -11 q) l9[3 0 2] -10 -11 1 2 77 88 we can also assign values to list at index using [] q) l9[0]:99 98 q) l9 99 98 30 40 50 77 88 -10 -11 q) l9[3]:enlist 100 q) l9 99 98 30 40 50 77 88 ,100 indexing can be done at depth as well for nested lists, by providing indexes of each level seperated by ; as we access value, similarly we assign as well if we dont specify index of a level that means we want all items of that level q) l9 99 98 30 40 50 77 88 ,100 q) l9[0;1] 98 q) l9[0;1]:909 / type of value should match with type of list q) l9 99 909 30 40 50 77 88 ,100 q) l9[;0] 99 30 77 100 / get first item at all level q) l9[0;] / get all items from first level 99 909 q) l9[0;99] / index out of range 0N q) type l9[0;99] / return null of type of first element of list -7h q) type first l9[0] 7h","title":"Lists"},{"location":"kdb-q/atom-lists/introduction_to_lists/#introduction-to-lists","text":"list is 2nd data structure in q, 1st is atom can be defined for all data types q) l: 1 2 3 4 / default type is float q) type l 7h / + means list, 7 means list of floats q) s:`q`w`e`r`t`y q) type s 11h / list of symbols useful function to creating list is til ** til n returns list of long integers starting from 0 and ending with n-1 q) l2: til 5 q) l2 0 1 2 3 4","title":"Introduction to lists"},{"location":"kdb-q/atom-lists/introduction_to_lists/#arithmetic-and-logical-operations-on-lists","text":"arithmetic and logical operation work atom by atom in a list q) l2+10 10 11 12 13 14 / 10 is added to all atoms of list q) l2:+5 / compound assignment to make changes in place q) 5 6 7 8 9 q) l2<7 11000b / returns boolean list, 1b at indexes where expression is true, this is also evaluated atom by atom","title":"Arithmetic and logical operations on lists"},{"location":"kdb-q/atom-lists/introduction_to_lists/#types-of-lists","text":"","title":"Types of lists"},{"location":"kdb-q/atom-lists/introduction_to_lists/#simple-list","text":"atoms in the list are of same types example: lists created by til q) l: til 4 q) l 0 1 2 3 q) type l 7h q) type each l -7 -7 -7 -7h","title":"Simple list"},{"location":"kdb-q/atom-lists/introduction_to_lists/#empty-list","text":"can be created using () with no type can also be forced to typed q) l3:() q) type l3 0h q) l4:`int$() q) type l4 6h","title":"Empty list"},{"location":"kdb-q/atom-lists/introduction_to_lists/#mixed-list","text":"contains entities[atoms, lists, etc.] of different types q) l5: (`q;23i;9.8f;\"hello\") q) l5 `q 23i 9.8000000000000007 \"hello\" q) type l5 0h q) type each l5 -11 -6 -9 10h equal = vs match ~ q) l6: 1 2 3 4i q) l7: 1 2 3 4f q) l6=l7 / checks underlying values 1111b q) l6~l7 / checks types as well 0b","title":"Mixed list"},{"location":"kdb-q/atom-lists/introduction_to_lists/#singleton-list","text":"if we try to assign 1 item to a variable, it will be an atom we use function enlist to make singleton list: list with single item q) l8:99 q) type l8 -7h / -ve sign means atom q) l8: enlist 99 q) type l8 7h / +ve sign means list q) type each l8 ,-7h q) l8 ,99 q) ```` ## Indexing and index assignment * indexing in list is done using `[]` - list`[`index/es`]` * indexes starts from `0` and ends with length_of_list-1 * in `[]` we can provide 1 index or list of indexes ```q q) l9: (1 2; 30 40 50; 77 88; -10 -11) q) l9 1 2 30 40 50 77 88 -10 -11 q) l9[0] 1 2 q) l9[3] -10 -11 q) l9[3 0 2] -10 -11 1 2 77 88 we can also assign values to list at index using [] q) l9[0]:99 98 q) l9 99 98 30 40 50 77 88 -10 -11 q) l9[3]:enlist 100 q) l9 99 98 30 40 50 77 88 ,100 indexing can be done at depth as well for nested lists, by providing indexes of each level seperated by ; as we access value, similarly we assign as well if we dont specify index of a level that means we want all items of that level q) l9 99 98 30 40 50 77 88 ,100 q) l9[0;1] 98 q) l9[0;1]:909 / type of value should match with type of list q) l9 99 909 30 40 50 77 88 ,100 q) l9[;0] 99 30 77 100 / get first item at all level q) l9[0;] / get all items from first level 99 909 q) l9[0;99] / index out of range 0N q) type l9[0;99] / return null of type of first element of list -7h q) type first l9[0] 7h","title":"Singleton list"},{"location":"kdb-q/atom-lists/list_operations/","text":"List Operations join , we can add atom/atoms/lists to list using , operator q) l: til 5 q) l 0 1 2 3 4 q) a:10 q) b:200 q) a,b 10 200 q) type a,b 7h q) l,a 0 1 2 3 4 10 q) l,a,b 0 1 2 3 4 10 200 q) l,:a q) l 0 1 2 3 4 10 q) l,4.35 / we can join items of different types to the list 0 1 2 3 4 10 4.35 drop _ (-/+)(n)number_of_elements_to_drop _ list if -ve, drop from end of list if +ve, drop from start of list if n is greater than length of list; return empty list of type same as first element q) l 0 1 2 3 4 10 q) 2_l 2 3 4 10 q) -2_l 0 1 2 3 q) -99_l `long$() if list is at left side of function _ then operand at right specifies index (list of indexes wont work) q) l 0 1 2 3 4 10 q) l _ 2 0 1 3 4 10 q) l _ 2 3 'domain cut atom/list cut list if left item is atom: cut list in that many equal parts if left item is list: cut list at those indexes q) l 0 1 2 3 4 10 99 q) 2 cut l / cut in 2 equal parts, if 1 item is left enlist it, return is always list 0 1 2 3 4 10 ,99 q) 3 cut l 0 1 2 3 4 10 ,99 q) 2 5 cut l / first cut at index 2, then at index 5, values shown are from index 2 to 5 then 5 till end of list 2 3 4 10 99 q) 0 2 5 cut l / in previous expression values from index 0 to 2 were not shown, we need to make cut at index 0 to show values before first non 0 index cut 0 1 2 3 4 10 99 take # its partner of drop (-/+)(n)number_of_elements_to_take # list if -ve, take from end of list if +ve, take from start of list if n is greater than length of list; return n elements by repeating list till required, i.e., list if wrapped around q) l 0 1 2 3 4 10 99 q) 2#l 0 1 q) -2#l 10 99 q) 2#l 0 1 q) 20#l 0 1 2 3 4 10 99 0 1 2 3 4 10 99 0 1 2 3 4 10 sublist x sublist list x can be atom or list if x is atom - return x number of elements starting from index 0 if x is greater than length of list, return list dont wrap around if x is list - return x[1] number of elements starting from x[0] q) l 0 1 2 3 4 10 99 q) 2 sublist l / return 2 elements from index 0 0 1 q) 2 5 sublist l / return 5 elements from index 2 2 3 4 10 99 q) 10 sublist l / x > count l , return list, no wrap around 0 1 2 3 4 10 99 q) 2 4 5 6 99 100 sublist l / x is list, 2<count x, x[1]=4 return 4 element, starting x[0]=2, ignore rest 2 3 4 10 q) 2 3 5 6 99 100 sublist l 2 3 4 Question mark ? 1. randomise -atom ? y atom is x * y is atom - return x distinct random element from til y * y is list - return x distinct random elements from list y * y is n (backtick n), return x distinct symbols of size n * if x > y or x > count y, 'length` error q) -3?5 / x is -ve, y is +ve, distinct elements 0 2 1 q) -6?5 / x is -ve, y is +ve, x>y 'length q) -5?5 / x is -ve, y is +ve, x=y, randomized til y 1 3 4 2 0 q) -5?til 5 / x is -ve, x=count y, randomized list y 2 0 3 4 1 q) -6?til 5 / x is -ve, x>count y 'length q) -20?`2 `bc`nc`km`fd`hk`ef`dl`mh`pg`pn`cd`dj`hl`pb`go`jl`ib`np`ok`ll atom ? y y is atom or list - return random elements from til y or list(y) q) 6?til 5 / x is +ve, x>count y 4 2 0 1 4 0 q) 5?til 5 / x is +ve, x=count y 3 4 4 1 3 q) 20?`2 `lb`kj`cd`ok`le`ce`ii`ji`ac`id`kp`ci`ie`kf`en`he`fp`bb`cj`mk 2. find ? list ? element return index of element from list if not found, return index where it might add i.e., 1+count list if more than 1 element exist in list, ? returns index of first occurence q) l 0 1 2 3 4 10 99 q) l?99 6 q) l?101 / element not in list, return 1+count l 7 q) l?101 102 7 7 / if more than 1 element not found, return same index i.e., 1+count l q) l,:10 q) l 0 1 2 3 4 10 99 10 q) l?10 5 first returns first element from list last returns last element from list raze flatten out 1 level of nesting from nested list distinct return distinct element from list count return count of number of elements in list union list1 union list2 - distinct elements from join of list1 and list2 inter return elements which are in both of them except list1 except list2 left which are not in right q) l 0 1 2 3 4 10 99 10 q) l2:5?l q) l2 99 2 3 2 2 q) l 0 1 2 3 4 10 99 10 q) first l2 99 q) last l 10 q) l3:(1 2 3; 4 5 6; (7;8)) q) l3 1 2 3 4 5 6 7 8 q) raze l3 1 2 3 4 5 6 7 8 q) distinct l 0 1 2 3 4 10 99 q) distinct l2 99 2 3 q) count l 8 q) count l2 5 q) l except l2 0 1 4 10 10 q) l union l2 0 1 2 3 4 10 99 q) l in l2 00110010b q) where l in l2 2 3 6 q) l where l in l2 2 3 99","title":"List Operations"},{"location":"kdb-q/atom-lists/list_operations/#list-operations","text":"","title":"List Operations"},{"location":"kdb-q/atom-lists/list_operations/#join","text":"we can add atom/atoms/lists to list using , operator q) l: til 5 q) l 0 1 2 3 4 q) a:10 q) b:200 q) a,b 10 200 q) type a,b 7h q) l,a 0 1 2 3 4 10 q) l,a,b 0 1 2 3 4 10 200 q) l,:a q) l 0 1 2 3 4 10 q) l,4.35 / we can join items of different types to the list 0 1 2 3 4 10 4.35","title":"join ,"},{"location":"kdb-q/atom-lists/list_operations/#drop-_","text":"(-/+)(n)number_of_elements_to_drop _ list if -ve, drop from end of list if +ve, drop from start of list if n is greater than length of list; return empty list of type same as first element q) l 0 1 2 3 4 10 q) 2_l 2 3 4 10 q) -2_l 0 1 2 3 q) -99_l `long$() if list is at left side of function _ then operand at right specifies index (list of indexes wont work) q) l 0 1 2 3 4 10 q) l _ 2 0 1 3 4 10 q) l _ 2 3 'domain","title":"drop _"},{"location":"kdb-q/atom-lists/list_operations/#cut","text":"atom/list cut list if left item is atom: cut list in that many equal parts if left item is list: cut list at those indexes q) l 0 1 2 3 4 10 99 q) 2 cut l / cut in 2 equal parts, if 1 item is left enlist it, return is always list 0 1 2 3 4 10 ,99 q) 3 cut l 0 1 2 3 4 10 ,99 q) 2 5 cut l / first cut at index 2, then at index 5, values shown are from index 2 to 5 then 5 till end of list 2 3 4 10 99 q) 0 2 5 cut l / in previous expression values from index 0 to 2 were not shown, we need to make cut at index 0 to show values before first non 0 index cut 0 1 2 3 4 10 99","title":"cut"},{"location":"kdb-q/atom-lists/list_operations/#take","text":"its partner of drop (-/+)(n)number_of_elements_to_take # list if -ve, take from end of list if +ve, take from start of list if n is greater than length of list; return n elements by repeating list till required, i.e., list if wrapped around q) l 0 1 2 3 4 10 99 q) 2#l 0 1 q) -2#l 10 99 q) 2#l 0 1 q) 20#l 0 1 2 3 4 10 99 0 1 2 3 4 10 99 0 1 2 3 4 10","title":"take #"},{"location":"kdb-q/atom-lists/list_operations/#sublist","text":"x sublist list x can be atom or list if x is atom - return x number of elements starting from index 0 if x is greater than length of list, return list dont wrap around if x is list - return x[1] number of elements starting from x[0] q) l 0 1 2 3 4 10 99 q) 2 sublist l / return 2 elements from index 0 0 1 q) 2 5 sublist l / return 5 elements from index 2 2 3 4 10 99 q) 10 sublist l / x > count l , return list, no wrap around 0 1 2 3 4 10 99 q) 2 4 5 6 99 100 sublist l / x is list, 2<count x, x[1]=4 return 4 element, starting x[0]=2, ignore rest 2 3 4 10 q) 2 3 5 6 99 100 sublist l 2 3 4","title":"sublist"},{"location":"kdb-q/atom-lists/list_operations/#question-mark","text":"","title":"Question mark ?"},{"location":"kdb-q/atom-lists/list_operations/#1-randomise","text":"","title":"1. randomise"},{"location":"kdb-q/atom-lists/list_operations/#-atomy","text":"atom is x * y is atom - return x distinct random element from til y * y is list - return x distinct random elements from list y * y is n (backtick n), return x distinct symbols of size n * if x > y or x > count y, 'length` error q) -3?5 / x is -ve, y is +ve, distinct elements 0 2 1 q) -6?5 / x is -ve, y is +ve, x>y 'length q) -5?5 / x is -ve, y is +ve, x=y, randomized til y 1 3 4 2 0 q) -5?til 5 / x is -ve, x=count y, randomized list y 2 0 3 4 1 q) -6?til 5 / x is -ve, x>count y 'length q) -20?`2 `bc`nc`km`fd`hk`ef`dl`mh`pg`pn`cd`dj`hl`pb`go`jl`ib`np`ok`ll","title":"-atom?y"},{"location":"kdb-q/atom-lists/list_operations/#atomy","text":"y is atom or list - return random elements from til y or list(y) q) 6?til 5 / x is +ve, x>count y 4 2 0 1 4 0 q) 5?til 5 / x is +ve, x=count y 3 4 4 1 3 q) 20?`2 `lb`kj`cd`ok`le`ce`ii`ji`ac`id`kp`ci`ie`kf`en`he`fp`bb`cj`mk","title":"atom?y"},{"location":"kdb-q/atom-lists/list_operations/#2-find","text":"","title":"2. find ?"},{"location":"kdb-q/atom-lists/list_operations/#listelement","text":"return index of element from list if not found, return index where it might add i.e., 1+count list if more than 1 element exist in list, ? returns index of first occurence q) l 0 1 2 3 4 10 99 q) l?99 6 q) l?101 / element not in list, return 1+count l 7 q) l?101 102 7 7 / if more than 1 element not found, return same index i.e., 1+count l q) l,:10 q) l 0 1 2 3 4 10 99 10 q) l?10 5","title":"list?element"},{"location":"kdb-q/atom-lists/list_operations/#first","text":"returns first element from list","title":"first"},{"location":"kdb-q/atom-lists/list_operations/#last","text":"returns last element from list","title":"last"},{"location":"kdb-q/atom-lists/list_operations/#raze","text":"flatten out 1 level of nesting from nested list","title":"raze"},{"location":"kdb-q/atom-lists/list_operations/#distinct","text":"return distinct element from list","title":"distinct"},{"location":"kdb-q/atom-lists/list_operations/#count","text":"return count of number of elements in list","title":"count"},{"location":"kdb-q/atom-lists/list_operations/#union","text":"list1 union list2 - distinct elements from join of list1 and list2","title":"union"},{"location":"kdb-q/atom-lists/list_operations/#inter","text":"return elements which are in both of them","title":"inter"},{"location":"kdb-q/atom-lists/list_operations/#except","text":"list1 except list2 left which are not in right q) l 0 1 2 3 4 10 99 10 q) l2:5?l q) l2 99 2 3 2 2 q) l 0 1 2 3 4 10 99 10 q) first l2 99 q) last l 10 q) l3:(1 2 3; 4 5 6; (7;8)) q) l3 1 2 3 4 5 6 7 8 q) raze l3 1 2 3 4 5 6 7 8 q) distinct l 0 1 2 3 4 10 99 q) distinct l2 99 2 3 q) count l 8 q) count l2 5 q) l except l2 0 1 4 10 10 q) l union l2 0 1 2 3 4 10 99 q) l in l2 00110010b q) where l in l2 2 3 6 q) l where l in l2 2 3 99","title":"except"},{"location":"kdb-q/dict_table_func/1_dictionaries/","text":"Dictionaries It is 3rd data structure in q after atom and lists Its mapping of lists: list of keys and list of values separated by ! Count of keys must be equal to count of values Data type is 99 q) l1:`q`w`e q) l2:`a`s`d q) l3:`z`x`c q) d1:(`A`B`C)!(l1;l2;l3) q) d1 A| q w e B| a s d C| z x c q) type dict 99h Accessing values in a dictionary access is done using key or list of keys with dictionary name q) d1`A `q`w`e q) d1`A`B q w e a s d function key or cols can be used to view keys of dictionary function value can be used to view values of dictionary q) key d1 `A`B`C q) cols d1 `A`B`C q) value d1 q w e a s d z x c keys in dictionary need not be unique trying to get value for repeating key will return value of first match for the key q) d3:(`q`q`w`e`q)!til 5 q) d3 q| 0 q| 1 w| 2 e| 3 q| 4 q) d3`q 0 dictionary can have nested lists or any q entity as values q) d4: (`q`w`e)!(((1 2 3);4 5); 1010b; 1 2 3f) q) d4 q| (1 2 3;4 5) w| 1010b e| 1 2 3f q) d4`q 1 2 3 4 5 Adding or modifying values to dictionary we can add new values using join , operator we can modify values using key as index and assign new value q)d1,(`P`Q)!(23 56;78 97f) / changes wont reflect in dictionary A| `q`w`e B| `a`s`d C| `z`x`c P| 23 56 Q| 78 97f q)d1,:(`P`Q)!(23 56;78 97f) / compounded assignment to make change in place q)d1 A| `q`w`e B| `a`s`d C| `z`x`c P| 23 56 Q| 78 97f q)d1[`P]: 100 102 / new value assigned q)d1 A| `q`w`e B| `a`s`d C| `z`x`c P| 100 102 Q| 78 97f","title":"Dictionaries"},{"location":"kdb-q/dict_table_func/1_dictionaries/#dictionaries","text":"It is 3rd data structure in q after atom and lists Its mapping of lists: list of keys and list of values separated by ! Count of keys must be equal to count of values Data type is 99 q) l1:`q`w`e q) l2:`a`s`d q) l3:`z`x`c q) d1:(`A`B`C)!(l1;l2;l3) q) d1 A| q w e B| a s d C| z x c q) type dict 99h","title":"Dictionaries"},{"location":"kdb-q/dict_table_func/1_dictionaries/#accessing-values-in-a-dictionary","text":"access is done using key or list of keys with dictionary name q) d1`A `q`w`e q) d1`A`B q w e a s d function key or cols can be used to view keys of dictionary function value can be used to view values of dictionary q) key d1 `A`B`C q) cols d1 `A`B`C q) value d1 q w e a s d z x c keys in dictionary need not be unique trying to get value for repeating key will return value of first match for the key q) d3:(`q`q`w`e`q)!til 5 q) d3 q| 0 q| 1 w| 2 e| 3 q| 4 q) d3`q 0 dictionary can have nested lists or any q entity as values q) d4: (`q`w`e)!(((1 2 3);4 5); 1010b; 1 2 3f) q) d4 q| (1 2 3;4 5) w| 1010b e| 1 2 3f q) d4`q 1 2 3 4 5","title":"Accessing values in a dictionary"},{"location":"kdb-q/dict_table_func/1_dictionaries/#adding-or-modifying-values-to-dictionary","text":"we can add new values using join , operator we can modify values using key as index and assign new value q)d1,(`P`Q)!(23 56;78 97f) / changes wont reflect in dictionary A| `q`w`e B| `a`s`d C| `z`x`c P| 23 56 Q| 78 97f q)d1,:(`P`Q)!(23 56;78 97f) / compounded assignment to make change in place q)d1 A| `q`w`e B| `a`s`d C| `z`x`c P| 23 56 Q| 78 97f q)d1[`P]: 100 102 / new value assigned q)d1 A| `q`w`e B| `a`s`d C| `z`x`c P| 100 102 Q| 78 97f","title":"Adding or modifying values to dictionary"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/","text":"Operation on dictionaries Join and lookup assignments we can join values using , if we want to join 1 key/value pair, we need to enlist them q) d:`q`w`e!(1 2 3; 4 5 6; 7 8 9) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 q) d,:`r`t!(9 8 7; 10 10 10) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 q) d,:(enlist `y)!(enlist 100) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 100 another way of adding key/value pair is using indexing we assign value to dictionary[new_key] this means we can do upsert, update if exists otherwise insert q)d[`u]: 44 55 q)d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 100 u| 44 55 q) d[`y]: 1 1 2 3 5 q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 1 1 2 3 5 u| 44 55 find ? left argument is dictionary and right argument is value: dictionary?value(s) if value dont exist, returns null of type of first key also works with nested values q) d2:`a`b`c! 11 22 33 q) d2 a| 11 b| 22 c| 33 q) d2?22 `b q) d2?22 33 `b`c q) d2?44 ` q) d3:(`a`b`c)!(10 20; 30 40; 50 60) q) d3 a| 10 20 b| 30 40 c| 50 60 q) d3?(10 20;50 60) `a`c drop _ left argument is key(s) and right argument is dictionary q) `a _ d3 b| 30 40 c| 50 60 q) `a`b _ d3 c| 50 60 take # left argument is key(s) and right argument is dictionary if key doesn't exist in dictionary, null values are returned q) `a`c#d3 a| 10 20 c| 50 60 Arithmetic operations function applied to dictionary is applied to its values if argument of function is dictionary, function is applied where keys match, otherwise values remain as is q) d4:`a`b`c`d`e!til 5 q) d4 a| 0 b| 1 c| 2 d| 3 e| 4 q) d5:`a`b`d! 10 20 30 q) d5 a| 10 b| 20 d| 30 q) d4*10 / function applied to all values a| 0 b| 10 c| 20 d| 30 e| 40 q) d4+d5 / keys of result is union of both keys with function applied on common keys a| 10 b| 21 c| 2 d| 33 e| 4 Logical operations similar to Arithmetic operations Logical operations also performed on all values if arguments are dictionaries, function applied to common keys q) d4>2 a| 0 b| 0 c| 0 d| 1 e| 1 q) d4>d5 a| 0 b| 0 d| 0 c| 1 e| 1 Mathematical operations Average avg operation is performed column-wise if we want average performed by keys we use function each q) d6:(`a`b`c)!(1 2 3; 40 50 60; 100 200 300) q) d6 a| 1 2 3 b| 40 50 60 c| 100 200 300 q) avg d6 47 84 121f q) avg each d6 a| 2 b| 50 c| 200 Creating a table we can create table using function flip dictionary needs to be column dictionary - meaning count of each value should match and keys as list of symbols value needs to be list not atom, we would need to enlist each of the values or enlist whole dictionary to get table q) d6 a| 1 2 3 b| 40 50 60 c| 100 200 300 q) flip d6 a b c -------- 1 40 100 2 50 200 3 60 300 q) type flip d6 98h q) d7:`a`b`c!til 3 q) d7 a| 0 b| 1 c| 2 q) flip d7 'rank [0] flip d7 ^ q) enlist d7 a b c ----- 0 1 2 q) flip enlist each d7 a b c ----- 0 1 2","title":"Operation on Dictionaries"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#operation-on-dictionaries","text":"","title":"Operation on dictionaries"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#join-and-lookup-assignments","text":"we can join values using , if we want to join 1 key/value pair, we need to enlist them q) d:`q`w`e!(1 2 3; 4 5 6; 7 8 9) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 q) d,:`r`t!(9 8 7; 10 10 10) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 q) d,:(enlist `y)!(enlist 100) q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 100 another way of adding key/value pair is using indexing we assign value to dictionary[new_key] this means we can do upsert, update if exists otherwise insert q)d[`u]: 44 55 q)d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 100 u| 44 55 q) d[`y]: 1 1 2 3 5 q) d q| 1 2 3 w| 4 5 6 e| 7 8 9 r| 9 8 7 t| 10 10 10 y| 1 1 2 3 5 u| 44 55","title":"Join and lookup assignments"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#find","text":"left argument is dictionary and right argument is value: dictionary?value(s) if value dont exist, returns null of type of first key also works with nested values q) d2:`a`b`c! 11 22 33 q) d2 a| 11 b| 22 c| 33 q) d2?22 `b q) d2?22 33 `b`c q) d2?44 ` q) d3:(`a`b`c)!(10 20; 30 40; 50 60) q) d3 a| 10 20 b| 30 40 c| 50 60 q) d3?(10 20;50 60) `a`c","title":"find ?"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#drop-_","text":"left argument is key(s) and right argument is dictionary q) `a _ d3 b| 30 40 c| 50 60 q) `a`b _ d3 c| 50 60","title":"drop _"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#take","text":"left argument is key(s) and right argument is dictionary if key doesn't exist in dictionary, null values are returned q) `a`c#d3 a| 10 20 c| 50 60","title":"take #"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#arithmetic-operations","text":"function applied to dictionary is applied to its values if argument of function is dictionary, function is applied where keys match, otherwise values remain as is q) d4:`a`b`c`d`e!til 5 q) d4 a| 0 b| 1 c| 2 d| 3 e| 4 q) d5:`a`b`d! 10 20 30 q) d5 a| 10 b| 20 d| 30 q) d4*10 / function applied to all values a| 0 b| 10 c| 20 d| 30 e| 40 q) d4+d5 / keys of result is union of both keys with function applied on common keys a| 10 b| 21 c| 2 d| 33 e| 4","title":"Arithmetic operations"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#logical-operations","text":"similar to Arithmetic operations Logical operations also performed on all values if arguments are dictionaries, function applied to common keys q) d4>2 a| 0 b| 0 c| 0 d| 1 e| 1 q) d4>d5 a| 0 b| 0 d| 0 c| 1 e| 1","title":"Logical operations"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#mathematical-operations","text":"Average avg operation is performed column-wise if we want average performed by keys we use function each q) d6:(`a`b`c)!(1 2 3; 40 50 60; 100 200 300) q) d6 a| 1 2 3 b| 40 50 60 c| 100 200 300 q) avg d6 47 84 121f q) avg each d6 a| 2 b| 50 c| 200","title":"Mathematical operations"},{"location":"kdb-q/dict_table_func/2_operations_on_dictionaries/#creating-a-table","text":"we can create table using function flip dictionary needs to be column dictionary - meaning count of each value should match and keys as list of symbols value needs to be list not atom, we would need to enlist each of the values or enlist whole dictionary to get table q) d6 a| 1 2 3 b| 40 50 60 c| 100 200 300 q) flip d6 a b c -------- 1 40 100 2 50 200 3 60 300 q) type flip d6 98h q) d7:`a`b`c!til 3 q) d7 a| 0 b| 1 c| 2 q) flip d7 'rank [0] flip d7 ^ q) enlist d7 a b c ----- 0 1 2 q) flip enlist each d7 a b c ----- 0 1 2","title":"Creating a table"},{"location":"kdb-q/dict_table_func/3_tables/","text":"Tables list of dictionaries or collection of named columns Simple table can be created by flipping a dictionary can be created using format ([] column_name: values; col...) data type is 98 q)t:([]a:1 2 3; b:4 5 6) q)t a b --- 1 4 2 5 3 6 Keyed table dictionary with mapping of table to table can be created using table format ([key_columns] column_name: values; col...) data type is 99 q)kt:([a:`a`b`c] b: 1 2 3; c:4 5 6) q)kt a| b c -| --- a| 1 4 b| 2 5 c| 3 6 q)type kt 99h Empty table used to specify schema of table before inserting anything in it we can force column type while defining, if defined, only values with matching type can be inserted q)et:([]a:(); b:()) q)et a b --- q)et2:([]a:`int$(); b:`float$()) q)et2 a b --- meta applied to a table will return table info c is for column names t is for type if values are lists, type will be represented by capital letters f is for foreign key a is for attributes q)meta kt c| t f a -| ----- a| s b| j c| j q)t2:([]a: ((1 2);(3 4)); b: 4 5f) q)t2 a b ----- 1 2 4 3 4 5 q)meta t2 c| t f a -| ----- a| J b| f Foreign keys table can be linked to another keyed table using foreign keys while defining foreign keys we use `keyed_table_name$values meta of new table will show f column to have linked to kt keyed_table_name q)kt a| b c -| --- a| 1 4 b| 2 5 c| 3 6 q)t3:([]id: `kt$`a`b`c; prc: 10 20 30f) q)t3 id prc ------ a 10 b 20 c 30 q)meta t3 c | t f a ---| ------ id | s kt prc| f Extracting rows and columns we can extract rows using row index number, return type is dictionary we can extract column using column name q)t[0] a| 1 b| 4 q)t[`a] 1 2 3 q)t[`a`b] 1 2 3 4 5 6 take operator # can be used to pull first n or last n rows from table similarly drop operator _ can be used q)2#t a b --- 1 4 2 5 q)-2#t a b --- 2 5 3 6 q)1 _ t a b --- 2 5 3 6 q)-1 _ t a b --- 1 4 2 5 Table lookup we can lookup using find operator we can also find using list(row values) in a table q)t2:([]a: 1 2 3; b: 4 5 6; c: 7 8 9) q)t2 a b c ----- 1 4 7 2 5 8 3 6 9 q)t2?`a`b`c!3 6 9 2 q)t2?3 6 9 2 q)t2?(2 5 8; 3 6 9) 1 2 q)t2?([]a:1 2; b:4 5; c:7 8) 0 1 Table arithmetic we can perform arithmetic operations on keyed tables operation will be performed for matching keys and rest will remain unchanged q)kt1:([ks:`a`b`c] v1: 1 2 3; v2: 10 11 12) q)kt2:([ks:`b`c`e] v1: 20 30 40; v2: 100 101 102) q)kt1+kt2 ks| v1 v2 --| ------ a | 1 10 b | 22 111 c | 33 113 e | 40 102","title":"Tables"},{"location":"kdb-q/dict_table_func/3_tables/#tables","text":"list of dictionaries or collection of named columns","title":"Tables"},{"location":"kdb-q/dict_table_func/3_tables/#simple-table","text":"can be created by flipping a dictionary can be created using format ([] column_name: values; col...) data type is 98 q)t:([]a:1 2 3; b:4 5 6) q)t a b --- 1 4 2 5 3 6","title":"Simple table"},{"location":"kdb-q/dict_table_func/3_tables/#keyed-table","text":"dictionary with mapping of table to table can be created using table format ([key_columns] column_name: values; col...) data type is 99 q)kt:([a:`a`b`c] b: 1 2 3; c:4 5 6) q)kt a| b c -| --- a| 1 4 b| 2 5 c| 3 6 q)type kt 99h","title":"Keyed table"},{"location":"kdb-q/dict_table_func/3_tables/#empty-table","text":"used to specify schema of table before inserting anything in it we can force column type while defining, if defined, only values with matching type can be inserted q)et:([]a:(); b:()) q)et a b --- q)et2:([]a:`int$(); b:`float$()) q)et2 a b ---","title":"Empty table"},{"location":"kdb-q/dict_table_func/3_tables/#meta","text":"applied to a table will return table info c is for column names t is for type if values are lists, type will be represented by capital letters f is for foreign key a is for attributes q)meta kt c| t f a -| ----- a| s b| j c| j q)t2:([]a: ((1 2);(3 4)); b: 4 5f) q)t2 a b ----- 1 2 4 3 4 5 q)meta t2 c| t f a -| ----- a| J b| f","title":"meta"},{"location":"kdb-q/dict_table_func/3_tables/#foreign-keys","text":"table can be linked to another keyed table using foreign keys while defining foreign keys we use `keyed_table_name$values meta of new table will show f column to have linked to kt keyed_table_name q)kt a| b c -| --- a| 1 4 b| 2 5 c| 3 6 q)t3:([]id: `kt$`a`b`c; prc: 10 20 30f) q)t3 id prc ------ a 10 b 20 c 30 q)meta t3 c | t f a ---| ------ id | s kt prc| f","title":"Foreign keys"},{"location":"kdb-q/dict_table_func/3_tables/#extracting-rows-and-columns","text":"we can extract rows using row index number, return type is dictionary we can extract column using column name q)t[0] a| 1 b| 4 q)t[`a] 1 2 3 q)t[`a`b] 1 2 3 4 5 6 take operator # can be used to pull first n or last n rows from table similarly drop operator _ can be used q)2#t a b --- 1 4 2 5 q)-2#t a b --- 2 5 3 6 q)1 _ t a b --- 2 5 3 6 q)-1 _ t a b --- 1 4 2 5","title":"Extracting rows and columns"},{"location":"kdb-q/dict_table_func/3_tables/#table-lookup","text":"we can lookup using find operator we can also find using list(row values) in a table q)t2:([]a: 1 2 3; b: 4 5 6; c: 7 8 9) q)t2 a b c ----- 1 4 7 2 5 8 3 6 9 q)t2?`a`b`c!3 6 9 2 q)t2?3 6 9 2 q)t2?(2 5 8; 3 6 9) 1 2 q)t2?([]a:1 2; b:4 5; c:7 8) 0 1","title":"Table lookup"},{"location":"kdb-q/dict_table_func/3_tables/#table-arithmetic","text":"we can perform arithmetic operations on keyed tables operation will be performed for matching keys and rest will remain unchanged q)kt1:([ks:`a`b`c] v1: 1 2 3; v2: 10 11 12) q)kt2:([ks:`b`c`e] v1: 20 30 40; v2: 100 101 102) q)kt1+kt2 ks| v1 v2 --| ------ a | 1 10 b | 22 111 c | 33 113 e | 40 102","title":"Table arithmetic"},{"location":"kdb-q/dict_table_func/4_functions/","text":"Functions block of code used to perform particular task can be executed by using its name and passing required variables defined using {} arguments required can be passed inside function definition in [] output is the result of execution of last line which doesn't end with ; if we want to suppress the output we add ; to after last line of code q)f:{[a;b;c] a+b+c} q)f[4;5;6] 15 q)f:{[a;b;c] a+b+c ; } / if we add ; at end there is no output q)f[4;5;6] q) we can force the output using : , it also halts execution of function at that point q)f:{[a;b;c] :a+b+c; show \"x\"; } q)f[4;5;6] 15 Niladic Functions accept no arguments can be called with function name with no arguments or 1 argument which will be ignored q)f:{show \"func exec \"} q)f[] \"func exec \" q)f[`a] \"func exec \" Monadic functions takes exactly 1 argument not passing an argument or passing more than 1 argument, will cause error there are 3 special arguments x , y and z if we don't specify arguments names in function definition and pass an argument then, first argument will be stored in x, second in y and third in z q)f:{show \"func exec \"} q)f[] \"func exec\" q)f[`a] \"func exec\" q)f3:{show x; show y; show z} q)f3[\"Its\";\"Good\";\"Day\"] \"Its\" \"Good\" \"Day\" q)f3:{x*y*z} q)f3[4;5;6] 120 Diadic function takes 2 arguments, we can specify arguments or use implict arguments x , y and z q)f:{[a;b] a*b} q)f[5;4] 20 q)f4:{x*y} q)f4[5;4] 20 Triadic function takes 3 arguments, this is maximum where we can use implicit parameters x , y and z q) f:{x+y+z} q) f[1;2;3] 6 Multivalent function arguments more than 3 here we specifically need to define argument names q)f:{x+y+z+a} q)f[1;2;3;4] 'rank [0] f[1;2;3;4] ^ q)f:{[x;y;z;a] x+y+z+a} q)f[1;2;3;4] 10 Special functions Plus + these can be applied in prefix or infix form user defined functions cant be applied in infix form q)f:+ q)+[1;2] 3 q)1 + 2 3 q)1 f 2 'type [0] 1 f 2 ^ Max arguments max arguments we can pass is 8 we cant define a function with 9 parameters, we get 'params error we can pass more number of arguments in complex data structure as list or dictionary q)f:{[a;b;c;d;e;f;g;h;i] a+b+c+d+e+f+g+h+i} 'params q)f:{[a;b;c;d;e;f;g;h;i] a+b+c+d+e+f+g+h+i} 'params q)d:(10?\" \")!1+til 10 q)d i| 1 y| 2 c| 3 z| 4 m| 5 l| 6 w| 7 h| 8 e| 9 v| 10 q)f:{[d]sum d} q)f[d] 55 type of function function is of type 100h get function_name gives its structure q)type f 100h q)get f 0x78390002 ,`d `symbol$() ,` 8 4 \"..f\" \"\" -1 \"{[d]sum d}\" q)get [f][1] ,`d Function within function we can call and define a function within a function if we defined unnamed function within function its called lambda functions lambda lambdas need not be defined within a function we can define unnamed function(lambdas) by themselves q)z:{f:{x*x}; f[x]+10} q)z[2] 14 q)z:{10+{x*x}[x]} q)z[2] 14 q){x+y}[3;4] / lambda without assigning to any variable and outside a function 7 Projections if we need to change one parameter and keeping rest of parameters same, we use Projections if we change definition of f, definition of its projections wont change we can create projection of projection of another function/projection q)f:{x*y} q)f[4;5] 20 q)g:f[;5] q)type g 104h q)g / g is projection on f with y=5 {x*y}[;5] q)g[4] 20","title":"Functions"},{"location":"kdb-q/dict_table_func/4_functions/#functions","text":"block of code used to perform particular task can be executed by using its name and passing required variables defined using {} arguments required can be passed inside function definition in [] output is the result of execution of last line which doesn't end with ; if we want to suppress the output we add ; to after last line of code q)f:{[a;b;c] a+b+c} q)f[4;5;6] 15 q)f:{[a;b;c] a+b+c ; } / if we add ; at end there is no output q)f[4;5;6] q) we can force the output using : , it also halts execution of function at that point q)f:{[a;b;c] :a+b+c; show \"x\"; } q)f[4;5;6] 15","title":"Functions"},{"location":"kdb-q/dict_table_func/4_functions/#niladic-functions","text":"accept no arguments can be called with function name with no arguments or 1 argument which will be ignored q)f:{show \"func exec \"} q)f[] \"func exec \" q)f[`a] \"func exec \"","title":"Niladic Functions"},{"location":"kdb-q/dict_table_func/4_functions/#monadic-functions","text":"takes exactly 1 argument not passing an argument or passing more than 1 argument, will cause error there are 3 special arguments x , y and z if we don't specify arguments names in function definition and pass an argument then, first argument will be stored in x, second in y and third in z q)f:{show \"func exec \"} q)f[] \"func exec\" q)f[`a] \"func exec\" q)f3:{show x; show y; show z} q)f3[\"Its\";\"Good\";\"Day\"] \"Its\" \"Good\" \"Day\" q)f3:{x*y*z} q)f3[4;5;6] 120","title":"Monadic functions"},{"location":"kdb-q/dict_table_func/4_functions/#diadic-function","text":"takes 2 arguments, we can specify arguments or use implict arguments x , y and z q)f:{[a;b] a*b} q)f[5;4] 20 q)f4:{x*y} q)f4[5;4] 20","title":"Diadic function"},{"location":"kdb-q/dict_table_func/4_functions/#triadic-function","text":"takes 3 arguments, this is maximum where we can use implicit parameters x , y and z q) f:{x+y+z} q) f[1;2;3] 6","title":"Triadic function"},{"location":"kdb-q/dict_table_func/4_functions/#multivalent-function","text":"arguments more than 3 here we specifically need to define argument names q)f:{x+y+z+a} q)f[1;2;3;4] 'rank [0] f[1;2;3;4] ^ q)f:{[x;y;z;a] x+y+z+a} q)f[1;2;3;4] 10","title":"Multivalent function"},{"location":"kdb-q/dict_table_func/4_functions/#special-functions","text":"","title":"Special functions"},{"location":"kdb-q/dict_table_func/4_functions/#plus","text":"these can be applied in prefix or infix form user defined functions cant be applied in infix form q)f:+ q)+[1;2] 3 q)1 + 2 3 q)1 f 2 'type [0] 1 f 2 ^","title":"Plus +"},{"location":"kdb-q/dict_table_func/4_functions/#max-arguments","text":"max arguments we can pass is 8 we cant define a function with 9 parameters, we get 'params error we can pass more number of arguments in complex data structure as list or dictionary q)f:{[a;b;c;d;e;f;g;h;i] a+b+c+d+e+f+g+h+i} 'params q)f:{[a;b;c;d;e;f;g;h;i] a+b+c+d+e+f+g+h+i} 'params q)d:(10?\" \")!1+til 10 q)d i| 1 y| 2 c| 3 z| 4 m| 5 l| 6 w| 7 h| 8 e| 9 v| 10 q)f:{[d]sum d} q)f[d] 55","title":"Max arguments"},{"location":"kdb-q/dict_table_func/4_functions/#type-of-function","text":"function is of type 100h get function_name gives its structure q)type f 100h q)get f 0x78390002 ,`d `symbol$() ,` 8 4 \"..f\" \"\" -1 \"{[d]sum d}\" q)get [f][1] ,`d","title":"type of function"},{"location":"kdb-q/dict_table_func/4_functions/#function-within-function","text":"we can call and define a function within a function if we defined unnamed function within function its called lambda functions","title":"Function within function"},{"location":"kdb-q/dict_table_func/4_functions/#lambda","text":"lambdas need not be defined within a function we can define unnamed function(lambdas) by themselves q)z:{f:{x*x}; f[x]+10} q)z[2] 14 q)z:{10+{x*x}[x]} q)z[2] 14 q){x+y}[3;4] / lambda without assigning to any variable and outside a function 7","title":"lambda"},{"location":"kdb-q/dict_table_func/4_functions/#projections","text":"if we need to change one parameter and keeping rest of parameters same, we use Projections if we change definition of f, definition of its projections wont change we can create projection of projection of another function/projection q)f:{x*y} q)f[4;5] 20 q)g:f[;5] q)type g 104h q)g / g is projection on f with y=5 {x*y}[;5] q)g[4] 20","title":"Projections"},{"location":"kdb-q/dict_table_func/5_execution_control/","text":"Execution control if statement syntax if[condition; expression1; expression2; .. ; expressionN] if condition is true execute all expressions till expressionN . 0 is false , non zero values positive or negative are true . q)a:b:c:0 q)if[a>0;b:10;c:20] q)b 0 q)c 0 q)a:2 q)if[a>0;b:10;c:20] q)b 10 q)c 20 q)if[-20; show \"executed\"] \"executed\" q)if[20; show \"executed\"] \"executed\" q)if[0; show \"executed\"] q) $ if-else statement $ is used for if-else syntax: $[condition; trueExpr; falseExpr] nested syntax: $[condition; trueExpr; [condition2; trueExpr2; ...] ... falseExprN] ** here falseExprN will be executed when every condition1..N are false once a true condition is found, no execution is followed q)$[a<2; 1; a<4; 2; a<6; 3; a<8; 4; 20] 2 q)a 2 q)r:$[a=2;10;20] q)r 10 q)$[a<10; [b:99;c:100]; [b:100;c:101]] 100 q)b 99 q)c 100 ? vector conditional syntax ?[vector condition; trueExpr; falseExpr] trueExpr and falseExpr need to either atom of vector of same length as vector condition where vector condition is true trueExpr is returned else falseExpr is returned we need to be careful with type promotion: ** if trueExpr or falseExpr are of different type than original list, whole returned list will be converted to trueExpr or falseExpr type q)p:10?10 q)p 4 5 4 2 7 8 5 6 4 1 q)?[p<5;p;0] / where true, return p, else return 0 4 0 4 2 0 0 0 0 4 1 q)?[p<5;p;-1f] 4 -1 4 2 -1 -1 -1 -1 4 1f / whole list converted to float type q)?[p<5;p;0Nd] 2000.01.05 0N 2000.01.05 2000.01.03 0N 0N 0N 0N 2000.01.05 2000.01.02 while loop this is not generally used, same operation can be done using adverbs try to think of solution in vectorised form to use adverbs than while syntax: while[condition; expression/s] q)a 2 q)while[a>0; show a; a-:1] 2 1 do loop syntax: do[numberOfIterations; expression/s] execute expression/s numberOfIterations times do is useful when we want to time an expression \\t do[N; expr] though same can be done using \\t:N expr - this is not supported in 2.8 version ** useful when we want to see how our expression would scale for thousand or million rows q)i:0 q)do[10;show i; i+:1] 0 1 2 3 4 5 6 7 8 9 q)a:1000?100f q)b:1000?100f q)\\t a xexp b 0 q)\\t do[1000; a xexp b] 64 q)\\t:1000 a xexp b 62","title":"Execution Control"},{"location":"kdb-q/dict_table_func/5_execution_control/#execution-control","text":"","title":"Execution control"},{"location":"kdb-q/dict_table_func/5_execution_control/#if-statement","text":"syntax if[condition; expression1; expression2; .. ; expressionN] if condition is true execute all expressions till expressionN . 0 is false , non zero values positive or negative are true . q)a:b:c:0 q)if[a>0;b:10;c:20] q)b 0 q)c 0 q)a:2 q)if[a>0;b:10;c:20] q)b 10 q)c 20 q)if[-20; show \"executed\"] \"executed\" q)if[20; show \"executed\"] \"executed\" q)if[0; show \"executed\"] q)","title":"if statement"},{"location":"kdb-q/dict_table_func/5_execution_control/#if-else-statement","text":"$ is used for if-else syntax: $[condition; trueExpr; falseExpr] nested syntax: $[condition; trueExpr; [condition2; trueExpr2; ...] ... falseExprN] ** here falseExprN will be executed when every condition1..N are false once a true condition is found, no execution is followed q)$[a<2; 1; a<4; 2; a<6; 3; a<8; 4; 20] 2 q)a 2 q)r:$[a=2;10;20] q)r 10 q)$[a<10; [b:99;c:100]; [b:100;c:101]] 100 q)b 99 q)c 100","title":"$ if-else statement"},{"location":"kdb-q/dict_table_func/5_execution_control/#vector-conditional","text":"syntax ?[vector condition; trueExpr; falseExpr] trueExpr and falseExpr need to either atom of vector of same length as vector condition where vector condition is true trueExpr is returned else falseExpr is returned we need to be careful with type promotion: ** if trueExpr or falseExpr are of different type than original list, whole returned list will be converted to trueExpr or falseExpr type q)p:10?10 q)p 4 5 4 2 7 8 5 6 4 1 q)?[p<5;p;0] / where true, return p, else return 0 4 0 4 2 0 0 0 0 4 1 q)?[p<5;p;-1f] 4 -1 4 2 -1 -1 -1 -1 4 1f / whole list converted to float type q)?[p<5;p;0Nd] 2000.01.05 0N 2000.01.05 2000.01.03 0N 0N 0N 0N 2000.01.05 2000.01.02","title":"? vector conditional"},{"location":"kdb-q/dict_table_func/5_execution_control/#while-loop","text":"this is not generally used, same operation can be done using adverbs try to think of solution in vectorised form to use adverbs than while syntax: while[condition; expression/s] q)a 2 q)while[a>0; show a; a-:1] 2 1","title":"while loop"},{"location":"kdb-q/dict_table_func/5_execution_control/#do-loop","text":"syntax: do[numberOfIterations; expression/s] execute expression/s numberOfIterations times do is useful when we want to time an expression \\t do[N; expr] though same can be done using \\t:N expr - this is not supported in 2.8 version ** useful when we want to see how our expression would scale for thousand or million rows q)i:0 q)do[10;show i; i+:1] 0 1 2 3 4 5 6 7 8 9 q)a:1000?100f q)b:1000?100f q)\\t a xexp b 0 q)\\t do[1000; a xexp b] 64 q)\\t:1000 a xexp b 62","title":"do loop"},{"location":"kdb-q/dict_table_func/6_scripts/","text":"Scripts we can save, load and execute q expressions in .q file once q scipt is saved as .q file, we can load it from q console using \\l scriptFilePath.q or from command line using q scriptFilePath.q PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q)\\\\ PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)\\l test.q \"Loading q script\" q)\\\\ if we define variables in q script same will be accessible in q console once script is loaded, but if same variables are already defined they will be overwritten PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)a:88 q)a 88 q)\\l test.q \"Loading q script\" q)a 90 q)b 42 84 q) / used for single line comment multi line comments would start with / and end with \\ expression can be defined in multiple lines but when carried forward to next line whitespace is necessary whitespace needs to be there especially in function definition where multi-line definition of function needs whitespace before each new line including last } PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)\\l test.q \"Loading q script\" '( [0] C:\\Users\\Yogesh\\Desktop\\scripts\\test.q:17: tab2:(a:10?`1; b:10?.z.d; ^ [0] (<load>) )\\ q)\\v `s#`a`b`tab q)tab a b c ---------------------- n 2004.02.01 1.963762 j 2005.06.06 2.585456 c 2017.06.05 2.579898 h 2013.02.11 2.033321 a 2010.12.20 0.8904193 b 2005.03.04 1.508861 o 2009.05.09 3.925165 j 2016.09.30 2.673548 c 2017.09.06 3.555858 b 2015.08.10 2.057985 q)\\l test.q \"Loading q script\" '{ [0] C:\\Users\\Yogesh\\Desktop\\scripts\\test.q:17: fun:{[a;b] ^ [0] (<load>) ) Command line parameters we can launch script with key value parameters q script.q -key1 value1 -key2 value2 .... upto n .z.x stores our command line arguments as strings and can be used to access them inside the script .Q.opt is useful to convert output of .z.x into meaningful dictionary with values passed with -key becomes as keys of dictionary we can store output of .Q.opt .z.x into a variable and this dictionary can be used within script in many ways another useful function is .z.f which stores name of script when script has finished loading q) / without .Q.opt PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q -key test -xor test2 KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q) show .z.x \"-key\" \"test\" \"-xor\" \"test2\" q)/ with .Q.opt PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q -key test -xor test2 KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q) show .Q.opt .z.x key| \"test\" xor| \"test2\" q)","title":"Scripts"},{"location":"kdb-q/dict_table_func/6_scripts/#scripts","text":"we can save, load and execute q expressions in .q file once q scipt is saved as .q file, we can load it from q console using \\l scriptFilePath.q or from command line using q scriptFilePath.q PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q)\\\\ PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)\\l test.q \"Loading q script\" q)\\\\ if we define variables in q script same will be accessible in q console once script is loaded, but if same variables are already defined they will be overwritten PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)a:88 q)a 88 q)\\l test.q \"Loading q script\" q)a 90 q)b 42 84 q) / used for single line comment multi line comments would start with / and end with \\ expression can be defined in multiple lines but when carried forward to next line whitespace is necessary whitespace needs to be there especially in function definition where multi-line definition of function needs whitespace before each new line including last } PS C:\\Users\\Yogesh\\Desktop\\scripts> q KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ q)\\l test.q \"Loading q script\" '( [0] C:\\Users\\Yogesh\\Desktop\\scripts\\test.q:17: tab2:(a:10?`1; b:10?.z.d; ^ [0] (<load>) )\\ q)\\v `s#`a`b`tab q)tab a b c ---------------------- n 2004.02.01 1.963762 j 2005.06.06 2.585456 c 2017.06.05 2.579898 h 2013.02.11 2.033321 a 2010.12.20 0.8904193 b 2005.03.04 1.508861 o 2009.05.09 3.925165 j 2016.09.30 2.673548 c 2017.09.06 3.555858 b 2015.08.10 2.057985 q)\\l test.q \"Loading q script\" '{ [0] C:\\Users\\Yogesh\\Desktop\\scripts\\test.q:17: fun:{[a;b] ^ [0] (<load>) )","title":"Scripts"},{"location":"kdb-q/dict_table_func/6_scripts/#command-line-parameters","text":"we can launch script with key value parameters q script.q -key1 value1 -key2 value2 .... upto n .z.x stores our command line arguments as strings and can be used to access them inside the script .Q.opt is useful to convert output of .z.x into meaningful dictionary with values passed with -key becomes as keys of dictionary we can store output of .Q.opt .z.x into a variable and this dictionary can be used within script in many ways another useful function is .z.f which stores name of script when script has finished loading q) / without .Q.opt PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q -key test -xor test2 KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q) show .z.x \"-key\" \"test\" \"-xor\" \"test2\" q)/ with .Q.opt PS C:\\Users\\Yogesh\\Desktop\\scripts> q .\\test.q -key test -xor test2 KDB+ 3.5 2017.06.15 Copyright (C) 1993-2017 Kx Systems w32/ 4()core 4095MB Yogesh yogesh-hp 192.168.56.1 NONEXPIRE Welcome to kdb+ 32bit edition To exit, type \\\\ \"Loading q script\" q) show .Q.opt .z.x key| \"test\" xor| \"test2\" q)","title":"Command line parameters"},{"location":"kdb-q/dict_table_func/7_debugging/","text":"Debugging normal mode for q is q) q with single parenthesis q)) this means error trap or debug mode, q))) means error trap within error trap mode typing single \\ back slash used to toggle to k console to return back to q console type \\ from k console q)\\ / goes into k mode \\ q) / comes back to q mode ``` * if an error occurs while executing commands in console, it goes in error trap mode showing what type of error occured - `'type` is most common error :P * when it goes into error trap mode, its stuck where the error occurred, so if its within the function we can check what are the values passed which caused error ```q q)f:{x*y} q)f[3;4] 12 q)f[`sym;4] 'type [1] f:{x*y} q))x `sym q))y 4 ``` * 3 useful things to help debugging: ** `.z.s` shows function definition where its stuck when in error trap mode - useful for nested functions ** `'` tick - used to go 1 level higher in case of nested functions ** `:` or `:value` - we can force to continue the execution with `:value` meaning use value provided with `:` instead of where error is occurring and continue the execution ```q q)f:{x*x} q)g:{f[x]*y+10} q)g[3;4] 126 q)g[`aa;4] 'type [2] f:{x*x} ^ q)).z.s / print function where error is {x*x} q))' / go 1 level up - it goes from f to g ' [1] g:{f[x]*y+10} ^ q)):3 / continue execution with value 3 - thus 10+4=14*3=42 42 another example q)f:{x+10} q)g:{x*2} q)h:{n:f[x]+4; m:n+g[x] +g[y]} q)h[2;10] 40 q)h[`aa;10] 'type [2] f:{x+10} ^ q)).z.s / error at f[x] {x+10} q)):10 / we force execution with 10 - thus f[x] is 10 now - thus n:14 'type [2] g:{x*2} ^ q)).z.s / now we are stuck at g[x] {x*2} q)):2 / we force execution with 2 - thus g[x] is 2 now - thus m:14+2:16 + g[y]:10*2:20 - thus return value is m+20:16+20 36 to help with debugging within the function we use : and ' now these will help in debugging function line by line q)f:{a:x+3; y+5; a} q)f[3;4] 6 q)f:{a:x+3; :y+5; a} / we can force return with : q)f[3;4] 9 q)f:{a:x+3; 'polo; a:99; a} / we can use ' as 'polo q)f[3] 'polo [1] f:{a:x+3; 'polo; a:99; a} ^ q))a / we check a isnt assigned 99 till now coz there break statement before it 6 q))\\ q) we can also use 0N! and -3! to return each statement of function as its evaluated or print as string q)f:{0N!a:x+3;0N!a*:a; 0N!a+3} q)f[3] 6 36 39 39 q)f:{0N!a:x+3;0N!a*:a; -3!a+3} q)f[3] 6 36 \"39\"","title":"Debugging"},{"location":"kdb-q/dict_table_func/7_debugging/#debugging","text":"normal mode for q is q) q with single parenthesis q)) this means error trap or debug mode, q))) means error trap within error trap mode typing single \\ back slash used to toggle to k console to return back to q console type \\ from k console q)\\ / goes into k mode \\ q) / comes back to q mode ``` * if an error occurs while executing commands in console, it goes in error trap mode showing what type of error occured - `'type` is most common error :P * when it goes into error trap mode, its stuck where the error occurred, so if its within the function we can check what are the values passed which caused error ```q q)f:{x*y} q)f[3;4] 12 q)f[`sym;4] 'type [1] f:{x*y} q))x `sym q))y 4 ``` * 3 useful things to help debugging: ** `.z.s` shows function definition where its stuck when in error trap mode - useful for nested functions ** `'` tick - used to go 1 level higher in case of nested functions ** `:` or `:value` - we can force to continue the execution with `:value` meaning use value provided with `:` instead of where error is occurring and continue the execution ```q q)f:{x*x} q)g:{f[x]*y+10} q)g[3;4] 126 q)g[`aa;4] 'type [2] f:{x*x} ^ q)).z.s / print function where error is {x*x} q))' / go 1 level up - it goes from f to g ' [1] g:{f[x]*y+10} ^ q)):3 / continue execution with value 3 - thus 10+4=14*3=42 42 another example q)f:{x+10} q)g:{x*2} q)h:{n:f[x]+4; m:n+g[x] +g[y]} q)h[2;10] 40 q)h[`aa;10] 'type [2] f:{x+10} ^ q)).z.s / error at f[x] {x+10} q)):10 / we force execution with 10 - thus f[x] is 10 now - thus n:14 'type [2] g:{x*2} ^ q)).z.s / now we are stuck at g[x] {x*2} q)):2 / we force execution with 2 - thus g[x] is 2 now - thus m:14+2:16 + g[y]:10*2:20 - thus return value is m+20:16+20 36 to help with debugging within the function we use : and ' now these will help in debugging function line by line q)f:{a:x+3; y+5; a} q)f[3;4] 6 q)f:{a:x+3; :y+5; a} / we can force return with : q)f[3;4] 9 q)f:{a:x+3; 'polo; a:99; a} / we can use ' as 'polo q)f[3] 'polo [1] f:{a:x+3; 'polo; a:99; a} ^ q))a / we check a isnt assigned 99 till now coz there break statement before it 6 q))\\ q) we can also use 0N! and -3! to return each statement of function as its evaluated or print as string q)f:{0N!a:x+3;0N!a*:a; 0N!a+3} q)f[3] 6 36 39 39 q)f:{0N!a:x+3;0N!a*:a; -3!a+3} q)f[3] 6 36 \"39\"","title":"Debugging"},{"location":"kdb-q/fileio/load-save-files/","text":"","title":"Load save files"},{"location":"kdb-q/fileio/on-disk-tables/","text":"On Disk Tables We can save a table to disk in 3 different formats 1. flat table 2. splayed table 3. partitioned table Flat Table Saved to disk as-is, with all the information in one file These can only be used by loading them into memory Used only by small, frequently used databases Generally not suitable for large dataset Save flat table Lets create a table in-memory q)price:([]fruit: `banana`grapes`orange; qty: 10 15 13; prc: 10.78 40.88 30.87) q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 we can save the table to disk using handle_to_file set table_name here handle_to_file can be relative if saving in current directory or full path if saving in another directory provided write permissions are valid q)`:pricetab set price `:pricetab or we can use save in case we want to keep filename same as tablename q)save `:price `:price after saving to disk we can see there are two flat files in the working directory q)system\"ls -lh\" \"total 16\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" Load flat table to read these flat files we can use function get or load q)get `:price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)load `:pricetab `pricetab q)pricetab fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 Splayed table In splayed table a directory is created with name same as table name and having files for each columns and also a .d file which contains the order of the columns to splay we add the / to the end of file handle to specify it is a directory - it is same for both unix and windows system i.e; / forward slash Save splayed tables let's create a new table called prices2 which we can save as splayed table q)prices2:([]cars:\"ABC\"; price: 500 1100 1500 ; qty: 1000 350 20) q)prices2 cars price qty --------------- A 500 1000 B 1100 350 C 1500 20 we can save splayed table using set but adding / at the end of file handle q)`:splayedprice2/ set prices2 `:splayedprice2/ q)system\"ls -lh\" \"total 16\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 22:43 splayedprice2\" q)system\"ls -alh splayedprice2\" \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 22:43 .\" \"drwxr-xr-x 5 ranayk staff 160B Oct 4 22:43 ..\" \"-rw-r--r-- 1 ranayk staff 23B Oct 4 22:43 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 22:43 cars\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 22:43 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 22:43 qty\" Load splayed tables when we load the splayed table into the memory it is mapped to the memory not loaded into the memory - we can see this by checking mmap value from result of .Q.w[] function before loading the table .Q.w[] shows 0 for mmap ```qq).Q.w[] used| 357056 heap| 67108864 peak| 67108864 wmax| 0 mmap| 0 mphy| 8589934592 syms| 663 symw| 28351 * we can load the splayed table using `get` * after loading the table into memory we can re-examine the `mmap` value from `.Q.w[]` output ```q q)prices2 cars price qty --------------- A 500 1000 B 1100 350 C 1500 20 q).Q.w[] used| 358336 heap| 67108864 peak| 67108864 wmax| 0 mmap| 99 mphy| 8589934592 syms| 669 symw| 28547 Edit splayed table on disk we can re-order the table's columns by editing .d file q)get `:splayedprice2/.d `cars`price`qty q)`:splayedprice2/.d set `qty`price`cars `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C we can add the columns to splayed table on disk and we need to edit the .d file as well q)`:splayedprice2/date set 2022.10.01 2022.10.02 2022.10.03 `:splayedprice2/date q)`:splayedprice2/.d set (get `:splayedprice2/.d),`date `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars date -------------------------- 1000 500 A 2022.10.01 350 1100 B 2022.10.02 20 1500 C 2022.10.03 similarly we can delete the column from splayed table on disk using hdel and here as well we need to edit .d file q)hdel `:splayedprice2/date `:splayedprice2/date q)(get `:splayedprice2/.d) except `date `qty`price`cars q)`:splayedprice2/.d set (get `:splayedprice2/.d) except `date `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C we can also add a new row to splayed table on disk using upsert function q)`:splayedprice2/ upsert (1500;70;\"D\") `:splayedprice2/ q)get `:splayedprice2/ qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C 1500 70 D we can also sort the table - using xasc q)`qty xasc `:splayedprice2/ `:splayedprice2/ q)get `:splayedprice2/ qty price cars --------------- 20 1500 C 350 1100 B 1000 500 A 1500 70 D Partitioned tables Partitioned tables can be split horizontally as well as vertically - meaning data is split by row value(date or month) then each column is splayed into single file on disk - similar to splayed table Save partitioned table Lets define 2 tables for each parition and save them to disk using set here we are providing directory, parition and table name in file handle q)price1:([]car:\"ABC\";qty:10 20 30; price: 33 44 55) q)price1 car qty price ------------- A 10 33 B 20 44 C 30 55 q)price2:([]car:\"ZXY\";qty:99 88 77; price: 10 20 30) q)price2 car qty price ------------- Z 99 10 X 88 20 Y 77 30 on disk structure q)system\"ls -lah\" \"total 16\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x+ 54 ranayk staff 1.7K Oct 4 23:22 ..\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 partprice\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:04 splayedprice2\" q)system\"ls -lah partprice\" \"total 0\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 .\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 ..\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 2022.10.01\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 2022.10.02\" q)system\"ls -lah partprice/2022.10.01/\" \"total 0\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 .\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 ..\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 price\" q)system\"ls -lah partprice/2022.10.01/price/\" //if we had more tables in this partition it would show as another directory with directory name same as table's name \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 ..\" \"-rw-r--r-- 1 ranayk staff 22B Oct 4 23:25 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 23:25 car\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 qty\" q)system\"ls -lah partprice/2022.10.02/\" \"total 0\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 .\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 ..\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 price\" q)system\"ls -lah partprice/2022.10.02/price/\" \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 ..\" \"-rw-r--r-- 1 ranayk staff 22B Oct 4 23:25 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 23:25 car\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 qty\" Load the partitioned table we can use \\l with directory name to load the partitioned table q)\\l partprice q)price date car qty price ------------------------ 2022.10.01 A 10 33 2022.10.01 B 20 44 2022.10.01 C 30 55 2022.10.02 Z 99 10 2022.10.02 X 88 20 2022.10.02 Y 77 30 .Q.ind we can use .Q.ind to access rows of table by providing indexes as argument q).Q.ind[price;2 5] date car qty price ------------------------ 2022.10.01 C 30 55 2022.10.02 Y 77 30 .Q.chk if we have partitions with table directories missing then we can use .Q.chk to populate them using the schema of last parition q)\\ls \"partprice\" \"price\" \"pricetab\" \"splayedprice2\" q)system\"mkdir partprice/2022.10.03\" q)system\"ls -lh partprice/2022.10.03\" //latest partition doesn't have tables data populated \"total 0\" q).Q.chk[`:partprice] ,`:partprice/2022.10.03 () () q)system\"ls -lh partprice/2022.10.03\" //now it is populated \"total 0\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:39 price\" q)\\l partprice q)price date car qty price ------------------------ 2022.10.01 A 10 33 2022.10.01 B 20 44 2022.10.01 C 30 55 2022.10.02 Z 99 10 2022.10.02 X 88 20 2022.10.02 Y 77 30 directory structure till now partprice is partitioned table price and pricetab are flat tables, and splayedprice2 is splayed table \u251c\u2500\u2500 partprice \u2502 \u251c\u2500\u2500 2022.10.01 \u2502 \u2502 \u2514\u2500\u2500 price \u2502 \u2502 \u251c\u2500\u2500 car \u2502 \u2502 \u251c\u2500\u2500 price \u2502 \u2502 \u2514\u2500\u2500 qty \u2502 \u251c\u2500\u2500 2022.10.02 \u2502 \u2502 \u2514\u2500\u2500 price \u2502 \u2502 \u251c\u2500\u2500 car \u2502 \u2502 \u251c\u2500\u2500 price \u2502 \u2502 \u2514\u2500\u2500 qty \u2502 \u2514\u2500\u2500 2022.10.03 \u2502 \u2514\u2500\u2500 price \u2502 \u251c\u2500\u2500 car \u2502 \u251c\u2500\u2500 price \u2502 \u2514\u2500\u2500 qty \u251c\u2500\u2500 price \u251c\u2500\u2500 pricetab \u2514\u2500\u2500 splayedprice2 \u251c\u2500\u2500 cars \u251c\u2500\u2500 price \u2514\u2500\u2500 qty Now if we try to save splayed or partitioned table with symbol column it will fail as it needs enumeration Enumeration to enumerate means - unique symbols are identified and index assigned to each symbol - this map is stored in sym file in the root of database directory We use .Q.en to enumerate the table and generate/upsert values to sym file when saving down splayed or partitioned table q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)`:ensplayed/price/ set .Q.en[`:ensplayed;price] `:ensplayed/price/ now we can see additional sym file created for price splayed table under ensplayed directory q)system\"ls -lh\" \"total 16\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:52 ensplayed\" \"drwxr-xr-x 5 ranayk staff 160B Oct 4 23:38 partprice\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:04 splayedprice2\" q)system\"ls -lh ensplayed\" \"total 8\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:52 price\" \"-rw-r--r-- 1 ranayk staff 29B Oct 4 23:52 sym\" we can also load it into memory q)\\l ensplayed/price `price q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 .Q.dpft we can use .Q.dpft to save partitioned table on disk it needs table to be defined in-memory .Q.dpft - directory, partition, column to apply part attribute to, (in-memory)tablename q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)meta price c | t f a -----| ----- fruit| s qty | j prc | f q).Q.dpft[`:hdb;2022.10.01;`fruit;`price] `price directory structure hdb \u2514\u2500\u2500 2022.10.01 \u2514\u2500\u2500 price \u251c\u2500\u2500 fruit \u251c\u2500\u2500 prc \u2514\u2500\u2500 qty","title":"On Disk Tables"},{"location":"kdb-q/fileio/on-disk-tables/#on-disk-tables","text":"We can save a table to disk in 3 different formats 1. flat table 2. splayed table 3. partitioned table","title":"On Disk Tables"},{"location":"kdb-q/fileio/on-disk-tables/#flat-table","text":"Saved to disk as-is, with all the information in one file These can only be used by loading them into memory Used only by small, frequently used databases Generally not suitable for large dataset","title":"Flat Table"},{"location":"kdb-q/fileio/on-disk-tables/#save-flat-table","text":"Lets create a table in-memory q)price:([]fruit: `banana`grapes`orange; qty: 10 15 13; prc: 10.78 40.88 30.87) q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 we can save the table to disk using handle_to_file set table_name here handle_to_file can be relative if saving in current directory or full path if saving in another directory provided write permissions are valid q)`:pricetab set price `:pricetab or we can use save in case we want to keep filename same as tablename q)save `:price `:price after saving to disk we can see there are two flat files in the working directory q)system\"ls -lh\" \"total 16\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\"","title":"Save flat table"},{"location":"kdb-q/fileio/on-disk-tables/#load-flat-table","text":"to read these flat files we can use function get or load q)get `:price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)load `:pricetab `pricetab q)pricetab fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87","title":"Load flat table"},{"location":"kdb-q/fileio/on-disk-tables/#splayed-table","text":"In splayed table a directory is created with name same as table name and having files for each columns and also a .d file which contains the order of the columns to splay we add the / to the end of file handle to specify it is a directory - it is same for both unix and windows system i.e; / forward slash","title":"Splayed table"},{"location":"kdb-q/fileio/on-disk-tables/#save-splayed-tables","text":"let's create a new table called prices2 which we can save as splayed table q)prices2:([]cars:\"ABC\"; price: 500 1100 1500 ; qty: 1000 350 20) q)prices2 cars price qty --------------- A 500 1000 B 1100 350 C 1500 20 we can save splayed table using set but adding / at the end of file handle q)`:splayedprice2/ set prices2 `:splayedprice2/ q)system\"ls -lh\" \"total 16\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 22:43 splayedprice2\" q)system\"ls -alh splayedprice2\" \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 22:43 .\" \"drwxr-xr-x 5 ranayk staff 160B Oct 4 22:43 ..\" \"-rw-r--r-- 1 ranayk staff 23B Oct 4 22:43 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 22:43 cars\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 22:43 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 22:43 qty\"","title":"Save splayed tables"},{"location":"kdb-q/fileio/on-disk-tables/#load-splayed-tables","text":"when we load the splayed table into the memory it is mapped to the memory not loaded into the memory - we can see this by checking mmap value from result of .Q.w[] function before loading the table .Q.w[] shows 0 for mmap ```qq).Q.w[] used| 357056 heap| 67108864 peak| 67108864 wmax| 0 mmap| 0 mphy| 8589934592 syms| 663 symw| 28351 * we can load the splayed table using `get` * after loading the table into memory we can re-examine the `mmap` value from `.Q.w[]` output ```q q)prices2 cars price qty --------------- A 500 1000 B 1100 350 C 1500 20 q).Q.w[] used| 358336 heap| 67108864 peak| 67108864 wmax| 0 mmap| 99 mphy| 8589934592 syms| 669 symw| 28547","title":"Load splayed tables"},{"location":"kdb-q/fileio/on-disk-tables/#edit-splayed-table-on-disk","text":"we can re-order the table's columns by editing .d file q)get `:splayedprice2/.d `cars`price`qty q)`:splayedprice2/.d set `qty`price`cars `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C we can add the columns to splayed table on disk and we need to edit the .d file as well q)`:splayedprice2/date set 2022.10.01 2022.10.02 2022.10.03 `:splayedprice2/date q)`:splayedprice2/.d set (get `:splayedprice2/.d),`date `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars date -------------------------- 1000 500 A 2022.10.01 350 1100 B 2022.10.02 20 1500 C 2022.10.03 similarly we can delete the column from splayed table on disk using hdel and here as well we need to edit .d file q)hdel `:splayedprice2/date `:splayedprice2/date q)(get `:splayedprice2/.d) except `date `qty`price`cars q)`:splayedprice2/.d set (get `:splayedprice2/.d) except `date `:splayedprice2/.d q)load `:splayedprice2 `splayedprice2 q)splayedprice2 qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C we can also add a new row to splayed table on disk using upsert function q)`:splayedprice2/ upsert (1500;70;\"D\") `:splayedprice2/ q)get `:splayedprice2/ qty price cars --------------- 1000 500 A 350 1100 B 20 1500 C 1500 70 D we can also sort the table - using xasc q)`qty xasc `:splayedprice2/ `:splayedprice2/ q)get `:splayedprice2/ qty price cars --------------- 20 1500 C 350 1100 B 1000 500 A 1500 70 D","title":"Edit splayed table on disk"},{"location":"kdb-q/fileio/on-disk-tables/#partitioned-tables","text":"Partitioned tables can be split horizontally as well as vertically - meaning data is split by row value(date or month) then each column is splayed into single file on disk - similar to splayed table","title":"Partitioned tables"},{"location":"kdb-q/fileio/on-disk-tables/#save-partitioned-table","text":"Lets define 2 tables for each parition and save them to disk using set here we are providing directory, parition and table name in file handle q)price1:([]car:\"ABC\";qty:10 20 30; price: 33 44 55) q)price1 car qty price ------------- A 10 33 B 20 44 C 30 55 q)price2:([]car:\"ZXY\";qty:99 88 77; price: 10 20 30) q)price2 car qty price ------------- Z 99 10 X 88 20 Y 77 30 on disk structure q)system\"ls -lah\" \"total 16\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x+ 54 ranayk staff 1.7K Oct 4 23:22 ..\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 partprice\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:04 splayedprice2\" q)system\"ls -lah partprice\" \"total 0\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 .\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 ..\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 2022.10.01\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 2022.10.02\" q)system\"ls -lah partprice/2022.10.01/\" \"total 0\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 .\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 ..\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 price\" q)system\"ls -lah partprice/2022.10.01/price/\" //if we had more tables in this partition it would show as another directory with directory name same as table's name \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 ..\" \"-rw-r--r-- 1 ranayk staff 22B Oct 4 23:25 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 23:25 car\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 qty\" q)system\"ls -lah partprice/2022.10.02/\" \"total 0\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 .\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:25 ..\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 price\" q)system\"ls -lah partprice/2022.10.02/price/\" \"total 32\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:25 .\" \"drwxr-xr-x 3 ranayk staff 96B Oct 4 23:25 ..\" \"-rw-r--r-- 1 ranayk staff 22B Oct 4 23:25 .d\" \"-rw-r--r-- 1 ranayk staff 19B Oct 4 23:25 car\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 price\" \"-rw-r--r-- 1 ranayk staff 40B Oct 4 23:25 qty\"","title":"Save partitioned table"},{"location":"kdb-q/fileio/on-disk-tables/#load-the-partitioned-table","text":"we can use \\l with directory name to load the partitioned table q)\\l partprice q)price date car qty price ------------------------ 2022.10.01 A 10 33 2022.10.01 B 20 44 2022.10.01 C 30 55 2022.10.02 Z 99 10 2022.10.02 X 88 20 2022.10.02 Y 77 30","title":"Load the partitioned table"},{"location":"kdb-q/fileio/on-disk-tables/#qind","text":"we can use .Q.ind to access rows of table by providing indexes as argument q).Q.ind[price;2 5] date car qty price ------------------------ 2022.10.01 C 30 55 2022.10.02 Y 77 30","title":".Q.ind"},{"location":"kdb-q/fileio/on-disk-tables/#qchk","text":"if we have partitions with table directories missing then we can use .Q.chk to populate them using the schema of last parition q)\\ls \"partprice\" \"price\" \"pricetab\" \"splayedprice2\" q)system\"mkdir partprice/2022.10.03\" q)system\"ls -lh partprice/2022.10.03\" //latest partition doesn't have tables data populated \"total 0\" q).Q.chk[`:partprice] ,`:partprice/2022.10.03 () () q)system\"ls -lh partprice/2022.10.03\" //now it is populated \"total 0\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:39 price\" q)\\l partprice q)price date car qty price ------------------------ 2022.10.01 A 10 33 2022.10.01 B 20 44 2022.10.01 C 30 55 2022.10.02 Z 99 10 2022.10.02 X 88 20 2022.10.02 Y 77 30 directory structure till now partprice is partitioned table price and pricetab are flat tables, and splayedprice2 is splayed table \u251c\u2500\u2500 partprice \u2502 \u251c\u2500\u2500 2022.10.01 \u2502 \u2502 \u2514\u2500\u2500 price \u2502 \u2502 \u251c\u2500\u2500 car \u2502 \u2502 \u251c\u2500\u2500 price \u2502 \u2502 \u2514\u2500\u2500 qty \u2502 \u251c\u2500\u2500 2022.10.02 \u2502 \u2502 \u2514\u2500\u2500 price \u2502 \u2502 \u251c\u2500\u2500 car \u2502 \u2502 \u251c\u2500\u2500 price \u2502 \u2502 \u2514\u2500\u2500 qty \u2502 \u2514\u2500\u2500 2022.10.03 \u2502 \u2514\u2500\u2500 price \u2502 \u251c\u2500\u2500 car \u2502 \u251c\u2500\u2500 price \u2502 \u2514\u2500\u2500 qty \u251c\u2500\u2500 price \u251c\u2500\u2500 pricetab \u2514\u2500\u2500 splayedprice2 \u251c\u2500\u2500 cars \u251c\u2500\u2500 price \u2514\u2500\u2500 qty Now if we try to save splayed or partitioned table with symbol column it will fail as it needs enumeration","title":".Q.chk"},{"location":"kdb-q/fileio/on-disk-tables/#enumeration","text":"to enumerate means - unique symbols are identified and index assigned to each symbol - this map is stored in sym file in the root of database directory We use .Q.en to enumerate the table and generate/upsert values to sym file when saving down splayed or partitioned table q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)`:ensplayed/price/ set .Q.en[`:ensplayed;price] `:ensplayed/price/ now we can see additional sym file created for price splayed table under ensplayed directory q)system\"ls -lh\" \"total 16\" \"drwxr-xr-x 4 ranayk staff 128B Oct 4 23:52 ensplayed\" \"drwxr-xr-x 5 ranayk staff 160B Oct 4 23:38 partprice\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:26 price\" \"-rw-r--r-- 1 ranayk staff 118B Oct 4 22:25 pricetab\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:04 splayedprice2\" q)system\"ls -lh ensplayed\" \"total 8\" \"drwxr-xr-x 6 ranayk staff 192B Oct 4 23:52 price\" \"-rw-r--r-- 1 ranayk staff 29B Oct 4 23:52 sym\" we can also load it into memory q)\\l ensplayed/price `price q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87","title":"Enumeration"},{"location":"kdb-q/fileio/on-disk-tables/#qdpft","text":"we can use .Q.dpft to save partitioned table on disk it needs table to be defined in-memory .Q.dpft - directory, partition, column to apply part attribute to, (in-memory)tablename q)price fruit qty prc ---------------- banana 10 10.78 grapes 15 40.88 orange 13 30.87 q)meta price c | t f a -----| ----- fruit| s qty | j prc | f q).Q.dpft[`:hdb;2022.10.01;`fruit;`price] `price directory structure hdb \u2514\u2500\u2500 2022.10.01 \u2514\u2500\u2500 price \u251c\u2500\u2500 fruit \u251c\u2500\u2500 prc \u2514\u2500\u2500 qty","title":".Q.dpft"},{"location":"kdb-q/ipc_web_access/ipc-sending-receiving/","text":"IPC - Sending and Receiving server at port 1234 and client with handle opened to server q)// server q)\\p 1234i q)// client q)h:hopen 1234 q)h 3i Sync Send and Receive Synchronous message: client sends the message and blocks the handle until servers sends a response To send a message we can use \"string\" format along with handle h //client q)h\"2+2\" 4i q)h\"g:23\" q) //server q)g 23 Messages can also be send in functional form - handle(function;arg1;arg2;..;arg n) //client q)h(+;2;2) 4i q)h(set;`abc;245) `abc //server q)abc 234 For assigning value in functional form we use variable name as symbol or we can use function name as string We can also execute functions defined in server side from client //server q)f:{x*x} q)f {x*x} //client q)h(`f;2) 4 q)h(\"f\";2) 4 we can also send client side function to server along with arguments and get the results with server running the execution //client q)f2:{x-y} q)h(f2;45;23) 22 //server q)f2 'f2 [0] f2 ^ we can get data from server using get function or using variable name directly which exists in server //server q)list: 1 2 3 4 5 //client q)h(get;`list) 1 2 3 4 5 q)h(get;\"list\") 1 2 3 4 5 q)h\"list\" 1 2 3 4 5 q)h(\"list\") 1 2 3 4 5 .z.pg message handler function for handling synchronous messages executes everytime process/server receives synchronous message //server q).z.pg:{0N!value x} q)13 //client q)h\"2+3+8\" q)13 Async Send and Receive client doesn't wait for server to send the response, it continues its execution to send a async message we use negative handle Sending async messages does not send the message immediately. It serializes x, and queues it for sending at a later time - either when the main loop spins, or a blocking request is issued on that handle .z.ps async message handler //client q)(neg h)\"2*5\" q)(neg h)(+;2;5) q)(neg h)\"mko:908\" q)h\"\" // to ensure async messages queue is processed q)(neg h)[] //used to flush the queue //server q)mko 908 To confirm async messages are received and processed, chase with sync message q)h\"\" To block until all pending outgoing messages have been written into the handle q)(neg h)[] //or q)(neg h)(::) if we want to ensure an async message really has been sent as soon as possible, use: q)(neg h)\"x\"; q)(neg h)[];","title":"Send Receive"},{"location":"kdb-q/ipc_web_access/ipc-sending-receiving/#ipc-sending-and-receiving","text":"server at port 1234 and client with handle opened to server q)// server q)\\p 1234i q)// client q)h:hopen 1234 q)h 3i","title":"IPC - Sending and Receiving"},{"location":"kdb-q/ipc_web_access/ipc-sending-receiving/#sync-send-and-receive","text":"Synchronous message: client sends the message and blocks the handle until servers sends a response To send a message we can use \"string\" format along with handle h //client q)h\"2+2\" 4i q)h\"g:23\" q) //server q)g 23 Messages can also be send in functional form - handle(function;arg1;arg2;..;arg n) //client q)h(+;2;2) 4i q)h(set;`abc;245) `abc //server q)abc 234 For assigning value in functional form we use variable name as symbol or we can use function name as string We can also execute functions defined in server side from client //server q)f:{x*x} q)f {x*x} //client q)h(`f;2) 4 q)h(\"f\";2) 4 we can also send client side function to server along with arguments and get the results with server running the execution //client q)f2:{x-y} q)h(f2;45;23) 22 //server q)f2 'f2 [0] f2 ^ we can get data from server using get function or using variable name directly which exists in server //server q)list: 1 2 3 4 5 //client q)h(get;`list) 1 2 3 4 5 q)h(get;\"list\") 1 2 3 4 5 q)h\"list\" 1 2 3 4 5 q)h(\"list\") 1 2 3 4 5","title":"Sync Send and Receive"},{"location":"kdb-q/ipc_web_access/ipc-sending-receiving/#zpg","text":"message handler function for handling synchronous messages executes everytime process/server receives synchronous message //server q).z.pg:{0N!value x} q)13 //client q)h\"2+3+8\" q)13","title":".z.pg"},{"location":"kdb-q/ipc_web_access/ipc-sending-receiving/#async-send-and-receive","text":"client doesn't wait for server to send the response, it continues its execution to send a async message we use negative handle Sending async messages does not send the message immediately. It serializes x, and queues it for sending at a later time - either when the main loop spins, or a blocking request is issued on that handle .z.ps async message handler //client q)(neg h)\"2*5\" q)(neg h)(+;2;5) q)(neg h)\"mko:908\" q)h\"\" // to ensure async messages queue is processed q)(neg h)[] //used to flush the queue //server q)mko 908 To confirm async messages are received and processed, chase with sync message q)h\"\" To block until all pending outgoing messages have been written into the handle q)(neg h)[] //or q)(neg h)(::) if we want to ensure an async message really has been sent as soon as possible, use: q)(neg h)\"x\"; q)(neg h)[];","title":"Async Send and Receive"},{"location":"kdb-q/ipc_web_access/ipc_connecting/","text":"IPC: Connecting Kdb+ uses tcp/ip connection to talk between two kdb+ processes or when using http browser All messages in kdb+ connection goes via message handler functions to declare port number inside a q process we use /p [port_number] , we can also assign port number when starting the process using -p [port_number] when inside a process we can use \\p to see the port number, by default if port number is not declared it 0i user@host:~ $ q q)\\p 1234 q)\\p 1234i user@host:~ $ q -p 1234 q)\\p 1234i user@host:~ $ q q)\\p 0i let's create 2 q processes: server - one which is serving queries client - one which is making queries we can open a connection from client to server using function hopen we can also see which socket this handle is assigned to by checking value of h q)// server q)\\p 1234i q)// client q)h:hopen 1234 q)h 3i we can use another version of hopen command by specifyign host and port number - hopen ``:host:port q)// client q)h1: `:localhost:1234 q)h1 3i q)h1:`::1234 // if we dont provide host, it defaults to localhost q)h1 4i we can see all the handles open on client process by checking dictionary .z.W q)//client q).z.W q).z.W 3| 4| to close a connection we use function hclose we can also give handle number as an argument to hclose function to close a handle - handle number can be checked from .z.W command q)//client q)hclose h1 q)hclose 4i Message Handler Functions we can reset any of the message handler function to their original definition by using \\x function_name or \\x .z.pw .z.pw used to check password of user while opening connection arguments to .z.pw function are username and password can be reset to default using \\x .z.pw // server q)permittedusers:`abc`xyz`pqr q).z.pw:{[u;p] (u in permittedusers) and (p~\"pass\")} //client q)h:hopen `::1234 'access [0] h:hopen `::1234 ^ q)h:hopen `::1234:abc:pass q).z.W 7| .z.po this is executed whenever a handle is opened and after .z.pw has executed successfully we can print details of just opened handle in this function, like: ip address, username, date time and handle number argument passed to function .z.po is handle number .z.a - show ip address .z.p - current timestamp .z.u - user opening handle // server q).z.po:{[x] show(.z.a;.z.p;.z.u;x)} {[x] show(.z.a;.z.p;.z.u;x)} q)2130706433i 2022.02.21D03:38:51.578467000 `abc 10i //client q)h2:hopen `::1234:abc:pass .z.pc we can use .z.pc to be executed whenever a handle is closed to server //server q).z.pc:{[x] show(.z.h;.z.p;x)} q)`ykr-mbam1.local 2022.02.21D03:42:57.717442000 10i //client q)hclose h2 Timeout we can also define timeout in millisecods when opening a handle // server q)system \"sleep 60\" // client q)h2:hopen (`::1234:abc:pass;10) 'timeout [0] h2:hopen (`::1234:abc:pass;10) Restricting user access on start-up we can define username and password combination in a file and specify it using -u filepath when strating q session Only username password combination in the file will be allowed when opening handle // server ranayk@ykr-mbam1: $ cat users.txt abc:pass1 xyz:pass2 qwe:pass3 ranayk@ykr-mbam1: $ q -p 1234 -u users.txt KDB+ 4.0 2021.04.26 Copyright (C) 1993-2021 Kx Systems m64/ 8(16)core 8192MB ranayk ykr-mbam1.local 127.0.0.1 EXPIRE 2022.05.30 yankeekiloromeo@gmail.com KOD #4176402 q) //client q)h2:hopen `::1234:abc:pass 'access [0] h2:hopen `::1234:abc:pass ^ q)h2:hopen `::1234:abc:pass1 q)h2:hopen `::1234:xyz:pass1 'access [0] h2:hopen `::1234:xyz:pass1 ^ q)h2:hopen `::1234:xyz:pass2 q)","title":"Connecting"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#ipc-connecting","text":"Kdb+ uses tcp/ip connection to talk between two kdb+ processes or when using http browser All messages in kdb+ connection goes via message handler functions to declare port number inside a q process we use /p [port_number] , we can also assign port number when starting the process using -p [port_number] when inside a process we can use \\p to see the port number, by default if port number is not declared it 0i user@host:~ $ q q)\\p 1234 q)\\p 1234i user@host:~ $ q -p 1234 q)\\p 1234i user@host:~ $ q q)\\p 0i let's create 2 q processes: server - one which is serving queries client - one which is making queries we can open a connection from client to server using function hopen we can also see which socket this handle is assigned to by checking value of h q)// server q)\\p 1234i q)// client q)h:hopen 1234 q)h 3i we can use another version of hopen command by specifyign host and port number - hopen ``:host:port q)// client q)h1: `:localhost:1234 q)h1 3i q)h1:`::1234 // if we dont provide host, it defaults to localhost q)h1 4i we can see all the handles open on client process by checking dictionary .z.W q)//client q).z.W q).z.W 3| 4| to close a connection we use function hclose we can also give handle number as an argument to hclose function to close a handle - handle number can be checked from .z.W command q)//client q)hclose h1 q)hclose 4i","title":"IPC: Connecting"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#message-handler-functions","text":"we can reset any of the message handler function to their original definition by using \\x function_name or \\x .z.pw","title":"Message Handler Functions"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#zpw","text":"used to check password of user while opening connection arguments to .z.pw function are username and password can be reset to default using \\x .z.pw // server q)permittedusers:`abc`xyz`pqr q).z.pw:{[u;p] (u in permittedusers) and (p~\"pass\")} //client q)h:hopen `::1234 'access [0] h:hopen `::1234 ^ q)h:hopen `::1234:abc:pass q).z.W 7|","title":".z.pw"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#zpo","text":"this is executed whenever a handle is opened and after .z.pw has executed successfully we can print details of just opened handle in this function, like: ip address, username, date time and handle number argument passed to function .z.po is handle number .z.a - show ip address .z.p - current timestamp .z.u - user opening handle // server q).z.po:{[x] show(.z.a;.z.p;.z.u;x)} {[x] show(.z.a;.z.p;.z.u;x)} q)2130706433i 2022.02.21D03:38:51.578467000 `abc 10i //client q)h2:hopen `::1234:abc:pass","title":".z.po"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#zpc","text":"we can use .z.pc to be executed whenever a handle is closed to server //server q).z.pc:{[x] show(.z.h;.z.p;x)} q)`ykr-mbam1.local 2022.02.21D03:42:57.717442000 10i //client q)hclose h2","title":".z.pc"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#timeout","text":"we can also define timeout in millisecods when opening a handle // server q)system \"sleep 60\" // client q)h2:hopen (`::1234:abc:pass;10) 'timeout [0] h2:hopen (`::1234:abc:pass;10)","title":"Timeout"},{"location":"kdb-q/ipc_web_access/ipc_connecting/#restricting-user-access-on-start-up","text":"we can define username and password combination in a file and specify it using -u filepath when strating q session Only username password combination in the file will be allowed when opening handle // server ranayk@ykr-mbam1: $ cat users.txt abc:pass1 xyz:pass2 qwe:pass3 ranayk@ykr-mbam1: $ q -p 1234 -u users.txt KDB+ 4.0 2021.04.26 Copyright (C) 1993-2021 Kx Systems m64/ 8(16)core 8192MB ranayk ykr-mbam1.local 127.0.0.1 EXPIRE 2022.05.30 yankeekiloromeo@gmail.com KOD #4176402 q) //client q)h2:hopen `::1234:abc:pass 'access [0] h2:hopen `::1234:abc:pass ^ q)h2:hopen `::1234:abc:pass1 q)h2:hopen `::1234:xyz:pass1 'access [0] h2:hopen `::1234:xyz:pass1 ^ q)h2:hopen `::1234:xyz:pass2 q)","title":"Restricting user access on start-up"},{"location":"kdb-q/ipc_web_access/kdb-via-web-browser/","text":"kdb+ via browser lets open a q process and define port as 1234 and define some variables q)\\p 1234 q)\\p 1234i q)a:24 q)b:9 0 8 9 q)a 24 q)b 9 0 8 9 q)t:([]sym:`a`b`c;prc: 10.23 23.45 78.44;size: 99 55 22) q)t sym prc size -------------- a 10.23 99 b 23.45 55 c 78.44 22 q)f:{x*x} q)f {x*x} now if we open browser with address http://localhost:[portnumber]/ it will show variables list on 1 side and its value on other side we can execute simple commands using ? after url tables queries can also be executed in similar manner http://localhost:1234/?select from t where size=22 functions are not displayed in browser by default but can be seen using \\function_name functions can also be executed although not visible we can also save the data in a file - .csv .txt .xml format http://hostname:portnumber/filename.ext?variable_name_to_be_saved http://localhost:1234/tab.csv?t - will prompt to save table t in .csv format or we can also make query to table and result will be saved to file - http://localhost:1234/tab.csv?select from t where size=22 - will save result into tab.csv file","title":"Web Browser"},{"location":"kdb-q/ipc_web_access/kdb-via-web-browser/#kdb-via-browser","text":"lets open a q process and define port as 1234 and define some variables q)\\p 1234 q)\\p 1234i q)a:24 q)b:9 0 8 9 q)a 24 q)b 9 0 8 9 q)t:([]sym:`a`b`c;prc: 10.23 23.45 78.44;size: 99 55 22) q)t sym prc size -------------- a 10.23 99 b 23.45 55 c 78.44 22 q)f:{x*x} q)f {x*x} now if we open browser with address http://localhost:[portnumber]/ it will show variables list on 1 side and its value on other side we can execute simple commands using ? after url tables queries can also be executed in similar manner http://localhost:1234/?select from t where size=22 functions are not displayed in browser by default but can be seen using \\function_name functions can also be executed although not visible we can also save the data in a file - .csv .txt .xml format http://hostname:portnumber/filename.ext?variable_name_to_be_saved http://localhost:1234/tab.csv?t - will prompt to save table t in .csv format or we can also make query to table and result will be saved to file - http://localhost:1234/tab.csv?select from t where size=22 - will save result into tab.csv file","title":"kdb+ via browser"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/","text":"Keywords Table modification Keywords q)//setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[10000;1000] q)tables[] `depth`quotes`trades cols used to view columns of the table and also to view keys of the dictionary q)cols trades `time`sym`src`price`size xasc / xdesc used to sort the table by columns specified q)`price xasc trades time sym src price size ------------------------------------------------- 2020.12.26D08:34:34.754000000 AAPL O 25.12 1535 2020.12.26D08:34:01.151000000 AAPL L 25.14 5290 2020.12.26D08:35:52.188000000 AAPL N 25.15 3413 2020.12.26D08:42:18.951000000 AAPL L 25.16 1902 2020.12.26D08:33:35.987000000 AAPL L 25.18 4579 .. q)`price xdesc trades time sym src price size ------------------------------------------------ 2020.12.26D16:17:13.172000000 IBM L 43.88 2560 2020.12.26D15:29:24.817000000 IBM L 43.84 369 2020.12.26D16:12:52.607000000 IBM N 43.83 4454 2020.12.26D16:21:07.666000000 IBM O 43.82 3918 2020.12.26D16:13:22.181000000 IBM L 43.81 4869 .. more than 1 column can also be specified - it will first sort by first column, and if values are same for first then sort by next column q)`price`size xdesc trades time sym src price size ------------------------------------------------ 2020.12.26D16:17:13.172000000 IBM L 43.88 2560 2020.12.26D15:29:24.817000000 IBM L 43.84 369 2020.12.26D16:12:52.607000000 IBM N 43.83 4454 2020.12.26D16:21:07.666000000 IBM O 43.82 3918 2020.12.26D16:13:22.181000000 IBM L 43.81 4869 xcol used to rename columns of table it will only change column name from left to right it will rename with first column as first name provided by symbol list on left and so on.. q)`Time`Sym xcol trades Time Sym src price size ------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 .. xcols reorder columns of the table it doesn't have to complete list it moves the specified columns to the left of the table column names need to be valid column names q)`price`size xcols trades price size time sym src ------------------------------------------------- 35.46 2367 2020.12.26D08:00:17.350000000 CSCO N 29.05 27 2020.12.26D08:00:30.245000000 DELL N 25.37 2797 2020.12.26D08:01:40.842000000 AAPL L 35.46 1714 2020.12.26D08:02:11.579000000 CSCO L 35.5 166 2020.12.26D08:02:12.246000000 YHOO N .. q)`price`size`polo xcols trades 'polo [0] `price`size`polo xcols trades ^ q))\\ xkey used to make specified columns as key of table can be multiple columns as well to key table in-place provid table name as symbol q)`price`src xkey trades price src| time sym size ---------| --------------------------------------- 35.46 N | 2020.12.26D08:00:17.350000000 CSCO 2367 29.05 N | 2020.12.26D08:00:30.245000000 DELL 27 25.37 L | 2020.12.26D08:01:40.842000000 AAPL 2797 35.46 L | 2020.12.26D08:02:11.579000000 CSCO 1714 35.5 N | 2020.12.26D08:02:12.246000000 YHOO 166 .. q)`price`src xkey `trades `trades keys can be used to see keys of table q)keys trades `price`src q)keys quotes `symbol$() key to view full keyed columns of the table q)key trades price src --------- 35.46 N 29.05 N 25.37 L 35.46 L 35.5 N .. can also be used to get list of keys of the dictionary q)d:`ab`bv!1 2 q)d ab| 1 bv| 2 q)key d `ab`bv xgroup used to group by column/s of a table q)`src xgroup quotes src| time .. ---| ------------------------------------------------------------------------.. L | 2020.12.26D08:00:02.809000000 2020.12.26D08:00:10.646000000 2020.12.26D0.. O | 2020.12.26D08:00:09.282000000 2020.12.26D08:00:20.104000000 2020.12.26D0.. N | 2020.12.26D08:00:10.075000000 2020.12.26D08:00:11.107000000 2020.12.26D0.. ungroup can be used to flatten grouped table Statistical Keywords first , last , max , min , sum , avg used to find first, last, maximum, minimum, total and average of list/columns of table q)select max price, min price, first price, last price, sum price, avg price from trades price price1 price2 price3 price4 price5 -------------------------------------------- 43.88 25.12 35.46 29.16 34679.26 34.67926 sums , maxs , mins , avgs used to specify running total, running maximum, running minimum and running average from list/column of table q)select sums price, maxs price, mins price from trades price price1 price2 -------------------- 35.46 35.46 35.46 64.51 35.46 29.05 89.88 35.46 25.37 125.34 35.46 25.37 160.84 35.5 25.37 .. msum , mmax , mmin , mavg used for moving total, moving maximum, moving minimum, moving average from list/column of table moving windows size is defined as left argument q)select 2 msum price, 2 mmax price, 2 mmin price, 2 mavg price from trades price price1 price2 price3 -------------------------- 35.46 35.46 35.46 35.46 64.51 35.46 29.05 32.255 54.42 29.05 25.37 27.21 60.83 35.46 25.37 30.415 70.96 35.5 35.46 35.48 .. Other useful keywords q)//setup q)t:0!select from trades where sym=`GOOG q)t price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 .. differ returns true 1b if every element is different from previous element of the list/column of table always returns 1b for first element q)differ t`price 11101011111110111111111011111110111110111111111111011011111101111111111111011.. can be used to find where price did changed q)select from t where differ price price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 41.24 N 2020.12.26D08:42:37.510000000 GOOG 4959 .. deltas shows different between current and previous values of the list can be used to select trades where price has increased q)select from t where (deltas price)>0 price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.29 L 2020.12.26D08:47:15.737000000 GOOG 7592 41.32 O 2020.12.26D08:49:33.238000000 GOOG 3863 41.21 L 2020.12.26D09:08:34.960000000 GOOG 1534 .. next it moves the elements of the list 1 space to the left and filling the empty space with null prev it moves the elements of the list 1 space to the right and filling the empty space with null can be used to find duration between trades q)update duration:time-prev time from t price src time sym size duration ---------------------------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 0D00:00:47.147000000 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 0D00:06:24.544000000 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 0D00:00:15.473000000 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 0D00:11:26.021000000 .. xprev shifts the elements of the list specified numbers to the right xnext keyword doesn't exist we can replicate the effect by specifying -n as argument to xprev q)t`time 2020.12.26D08:10:37.457000000 2020.12.26D08:11:24.604000000 2020.12.26D08:17:.. q)2 xprev t`time 0N 0N 2020.12.26D08:10:37.457000000 2020.12.26D08:11:24.604000000 2020.12.26D.. q)-2 xprev t`time // works as xnext 2020.12.26D08:17:49.148000000 2020.12.26D08:18:04.621000000 2020.12.26D08:29:.. ^ - coalease - fill nulls used to fill 0N nulls in the list with specified atom or list items it type promote the element if filling element is of type greater than existing list q)3 ^ 1 2 3 0N 0N 1 2 3 3 3 q)3f ^ 1 2 3 0N 0N 1 2 3 3 3f q)type 1 2 3 0N 0N 7h q)type 3f ^ 1 2 3 0N 0N 9h q)4 5 6 7 8f ^ 1 2 3 0N 0N // also works if list of same length is provided as filling argument 1 2 3 7 8f fills it fills the nulls in the list with first non null element in the left q)fills 1 2 3 0N 0N 9 0N 8 0N 0N 1 2 3 3 3 9 9 8 8 8 iasc/idesc it returns index of the elements to sort the list in ascending or descending order q)l: 90 8928 4345 258972 2349827 q)idesc l 4 3 1 2 0 q)iasc l 0 2 1 3 4 it can be used to order a list w.r.t another list of same size q)m:(1 2 4 3; 6 4 5; 2 6 3 7 5; 2 5 ) q)m 1 2 4 3 6 4 5 2 6 3 7 5 2 5 q)count each m 4 3 5 2 q)m iasc count each m 2 5 6 4 5 1 2 4 3 2 6 3 7 5 q)iasc count each m 3 1 0 2 rank returns the positions would appear if it were sorted in sorted order equivalent to using iasc twice on a list q)l 90 8928 4345 258972 2349827 q)rank l 0 2 1 3 4 q)iasc iasc l 0 2 1 3 4 q)iasc l 0 2 1 3 4 can be used to rank the prices of trades q)update prcrank:rank price from t price src time sym size prcrank --------------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 111 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 124 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 116 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 117 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 109 .. xrank used to bucket the list into specified number of bucket and result values specify which bucket each element of the list will fit into q)l 90 8928 4345 258972 2349827 q)2 xrank l 0 0 0 1 1 q)1 xrank l 0 0 0 0 0 q)3 xrank l 0 1 0 1 2 q)4 xrank l 0 1 0 2 3 q)","title":"Keywords"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#keywords","text":"","title":"Keywords"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#table-modification-keywords","text":"q)//setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[10000;1000] q)tables[] `depth`quotes`trades","title":"Table modification Keywords"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#cols","text":"used to view columns of the table and also to view keys of the dictionary q)cols trades `time`sym`src`price`size","title":"cols"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xasc-xdesc","text":"used to sort the table by columns specified q)`price xasc trades time sym src price size ------------------------------------------------- 2020.12.26D08:34:34.754000000 AAPL O 25.12 1535 2020.12.26D08:34:01.151000000 AAPL L 25.14 5290 2020.12.26D08:35:52.188000000 AAPL N 25.15 3413 2020.12.26D08:42:18.951000000 AAPL L 25.16 1902 2020.12.26D08:33:35.987000000 AAPL L 25.18 4579 .. q)`price xdesc trades time sym src price size ------------------------------------------------ 2020.12.26D16:17:13.172000000 IBM L 43.88 2560 2020.12.26D15:29:24.817000000 IBM L 43.84 369 2020.12.26D16:12:52.607000000 IBM N 43.83 4454 2020.12.26D16:21:07.666000000 IBM O 43.82 3918 2020.12.26D16:13:22.181000000 IBM L 43.81 4869 .. more than 1 column can also be specified - it will first sort by first column, and if values are same for first then sort by next column q)`price`size xdesc trades time sym src price size ------------------------------------------------ 2020.12.26D16:17:13.172000000 IBM L 43.88 2560 2020.12.26D15:29:24.817000000 IBM L 43.84 369 2020.12.26D16:12:52.607000000 IBM N 43.83 4454 2020.12.26D16:21:07.666000000 IBM O 43.82 3918 2020.12.26D16:13:22.181000000 IBM L 43.81 4869","title":"xasc / xdesc"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xcol","text":"used to rename columns of table it will only change column name from left to right it will rename with first column as first name provided by symbol list on left and so on.. q)`Time`Sym xcol trades Time Sym src price size ------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 ..","title":"xcol"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xcols","text":"reorder columns of the table it doesn't have to complete list it moves the specified columns to the left of the table column names need to be valid column names q)`price`size xcols trades price size time sym src ------------------------------------------------- 35.46 2367 2020.12.26D08:00:17.350000000 CSCO N 29.05 27 2020.12.26D08:00:30.245000000 DELL N 25.37 2797 2020.12.26D08:01:40.842000000 AAPL L 35.46 1714 2020.12.26D08:02:11.579000000 CSCO L 35.5 166 2020.12.26D08:02:12.246000000 YHOO N .. q)`price`size`polo xcols trades 'polo [0] `price`size`polo xcols trades ^ q))\\","title":"xcols"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xkey","text":"used to make specified columns as key of table can be multiple columns as well to key table in-place provid table name as symbol q)`price`src xkey trades price src| time sym size ---------| --------------------------------------- 35.46 N | 2020.12.26D08:00:17.350000000 CSCO 2367 29.05 N | 2020.12.26D08:00:30.245000000 DELL 27 25.37 L | 2020.12.26D08:01:40.842000000 AAPL 2797 35.46 L | 2020.12.26D08:02:11.579000000 CSCO 1714 35.5 N | 2020.12.26D08:02:12.246000000 YHOO 166 .. q)`price`src xkey `trades `trades","title":"xkey"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#keys","text":"can be used to see keys of table q)keys trades `price`src q)keys quotes `symbol$()","title":"keys"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#key","text":"to view full keyed columns of the table q)key trades price src --------- 35.46 N 29.05 N 25.37 L 35.46 L 35.5 N .. can also be used to get list of keys of the dictionary q)d:`ab`bv!1 2 q)d ab| 1 bv| 2 q)key d `ab`bv","title":"key"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xgroup","text":"used to group by column/s of a table q)`src xgroup quotes src| time .. ---| ------------------------------------------------------------------------.. L | 2020.12.26D08:00:02.809000000 2020.12.26D08:00:10.646000000 2020.12.26D0.. O | 2020.12.26D08:00:09.282000000 2020.12.26D08:00:20.104000000 2020.12.26D0.. N | 2020.12.26D08:00:10.075000000 2020.12.26D08:00:11.107000000 2020.12.26D0.. ungroup can be used to flatten grouped table","title":"xgroup"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#statistical-keywords","text":"","title":"Statistical Keywords"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#first-last-max-min-sum-avg","text":"used to find first, last, maximum, minimum, total and average of list/columns of table q)select max price, min price, first price, last price, sum price, avg price from trades price price1 price2 price3 price4 price5 -------------------------------------------- 43.88 25.12 35.46 29.16 34679.26 34.67926","title":"first, last, max, min, sum, avg"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#sums-maxs-mins-avgs","text":"used to specify running total, running maximum, running minimum and running average from list/column of table q)select sums price, maxs price, mins price from trades price price1 price2 -------------------- 35.46 35.46 35.46 64.51 35.46 29.05 89.88 35.46 25.37 125.34 35.46 25.37 160.84 35.5 25.37 ..","title":"sums, maxs, mins, avgs"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#msum-mmax-mmin-mavg","text":"used for moving total, moving maximum, moving minimum, moving average from list/column of table moving windows size is defined as left argument q)select 2 msum price, 2 mmax price, 2 mmin price, 2 mavg price from trades price price1 price2 price3 -------------------------- 35.46 35.46 35.46 35.46 64.51 35.46 29.05 32.255 54.42 29.05 25.37 27.21 60.83 35.46 25.37 30.415 70.96 35.5 35.46 35.48 ..","title":"msum, mmax, mmin, mavg"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#other-useful-keywords","text":"q)//setup q)t:0!select from trades where sym=`GOOG q)t price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 ..","title":"Other useful keywords"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#differ","text":"returns true 1b if every element is different from previous element of the list/column of table always returns 1b for first element q)differ t`price 11101011111110111111111011111110111110111111111111011011111101111111111111011.. can be used to find where price did changed q)select from t where differ price price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 41.24 N 2020.12.26D08:42:37.510000000 GOOG 4959 ..","title":"differ"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#deltas","text":"shows different between current and previous values of the list can be used to select trades where price has increased q)select from t where (deltas price)>0 price src time sym size ------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 41.29 L 2020.12.26D08:47:15.737000000 GOOG 7592 41.32 O 2020.12.26D08:49:33.238000000 GOOG 3863 41.21 L 2020.12.26D09:08:34.960000000 GOOG 1534 ..","title":"deltas"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#next","text":"it moves the elements of the list 1 space to the left and filling the empty space with null","title":"next"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#prev","text":"it moves the elements of the list 1 space to the right and filling the empty space with null can be used to find duration between trades q)update duration:time-prev time from t price src time sym size duration ---------------------------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 0D00:00:47.147000000 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 0D00:06:24.544000000 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 0D00:00:15.473000000 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 0D00:11:26.021000000 ..","title":"prev"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xprev","text":"shifts the elements of the list specified numbers to the right xnext keyword doesn't exist we can replicate the effect by specifying -n as argument to xprev q)t`time 2020.12.26D08:10:37.457000000 2020.12.26D08:11:24.604000000 2020.12.26D08:17:.. q)2 xprev t`time 0N 0N 2020.12.26D08:10:37.457000000 2020.12.26D08:11:24.604000000 2020.12.26D.. q)-2 xprev t`time // works as xnext 2020.12.26D08:17:49.148000000 2020.12.26D08:18:04.621000000 2020.12.26D08:29:..","title":"xprev"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#-coalease-fill-nulls","text":"used to fill 0N nulls in the list with specified atom or list items it type promote the element if filling element is of type greater than existing list q)3 ^ 1 2 3 0N 0N 1 2 3 3 3 q)3f ^ 1 2 3 0N 0N 1 2 3 3 3f q)type 1 2 3 0N 0N 7h q)type 3f ^ 1 2 3 0N 0N 9h q)4 5 6 7 8f ^ 1 2 3 0N 0N // also works if list of same length is provided as filling argument 1 2 3 7 8f","title":"^ - coalease - fill nulls"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#fills","text":"it fills the nulls in the list with first non null element in the left q)fills 1 2 3 0N 0N 9 0N 8 0N 0N 1 2 3 3 3 9 9 8 8 8","title":"fills"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#iascidesc","text":"it returns index of the elements to sort the list in ascending or descending order q)l: 90 8928 4345 258972 2349827 q)idesc l 4 3 1 2 0 q)iasc l 0 2 1 3 4 it can be used to order a list w.r.t another list of same size q)m:(1 2 4 3; 6 4 5; 2 6 3 7 5; 2 5 ) q)m 1 2 4 3 6 4 5 2 6 3 7 5 2 5 q)count each m 4 3 5 2 q)m iasc count each m 2 5 6 4 5 1 2 4 3 2 6 3 7 5 q)iasc count each m 3 1 0 2","title":"iasc/idesc"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#rank","text":"returns the positions would appear if it were sorted in sorted order equivalent to using iasc twice on a list q)l 90 8928 4345 258972 2349827 q)rank l 0 2 1 3 4 q)iasc iasc l 0 2 1 3 4 q)iasc l 0 2 1 3 4 can be used to rank the prices of trades q)update prcrank:rank price from t price src time sym size prcrank --------------------------------------------------------- 41.29 L 2020.12.26D08:10:37.457000000 GOOG 1902 111 41.33 N 2020.12.26D08:11:24.604000000 GOOG 3150 124 41.31 L 2020.12.26D08:17:49.148000000 GOOG 2133 116 41.31 L 2020.12.26D08:18:04.621000000 GOOG 2623 117 41.28 N 2020.12.26D08:29:30.642000000 GOOG 825 109 ..","title":"rank"},{"location":"kdb-q/keywords_joins_adverbs_attributes/1_keywords/#xrank","text":"used to bucket the list into specified number of bucket and result values specify which bucket each element of the list will fit into q)l 90 8928 4345 258972 2349827 q)2 xrank l 0 0 0 1 1 q)1 xrank l 0 0 0 0 0 q)3 xrank l 0 1 0 1 2 q)4 xrank l 0 1 0 2 3 q)","title":"xrank"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/","text":"Joins q)// setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[1000;1000] q)tables[] `depth`quotes`trades Vertical Join , used to append 1 table at the end of another table q)t1:5#trades q)t2:-5#trades q)t1,t2 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D16:28:13.574000000 GOOG L 41.42 746 2020.12.26D16:28:51.196000000 NOK N 31.77 147 2020.12.26D16:28:56.993000000 CSCO O 35.51 6233 2020.12.26D16:29:05.901000000 AAPL L 25.32 64 2020.12.26D16:29:38.453000000 NOK N 31.81 307 columns of the 2 tables must match q)t1,5#quotes 'mismatch [0] t1,5#quotes ^ if we want to append subset of columns to table we must use ,: (join in-place) which will fill missing values with null q)t1,5#select time, sym, price from trades 'mismatch [0] t1,5#select time, sym, price from trades ^ q)t1,:5#select time, sym, price from trades q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D08:00:13.099000000 IBM 43.52 2020.12.26D08:00:39.491000000 CSCO 35.45 2020.12.26D08:01:46.279000000 AAPL 25.34 2020.12.26D08:02:09.670000000 AAPL 25.37 2020.12.26D08:02:31.911000000 ORCL 32.25 if we want to add single row of data, then also we must use join in-place( ,: ) q)t1,(.z.p;`GOOG;`N;45.55;098) `time`sym`src`price`size!(2020.12.26D08:00:13.099000000;`IBM;`N;43.52;326i) `time`sym`src`price`size!(2020.12.26D08:00:39.491000000;`CSCO;`L;35.45;2382i) `time`sym`src`price`size!(2020.12.26D08:01:46.279000000;`AAPL;`O;25.34;211i) `time`sym`src`price`size!(2020.12.26D08:02:09.670000000;`AAPL;`L;25.37;8077i) `time`sym`src`price`size!(2020.12.26D08:02:31.911000000;`ORCL;`L;32.25;5730i) `time`sym`src`price`size!(2020.12.26D08:00:13.099000000;`IBM;`;43.52;0Ni) `time`sym`src`price`size!(2020.12.26D08:00:39.491000000;`CSCO;`;35.45;0Ni) `time`sym`src`price`size!(2020.12.26D08:01:46.279000000;`AAPL;`;25.34;0Ni) `time`sym`src`price`size!(2020.12.26D08:02:09.670000000;`AAPL;`;25.37;0Ni) `time`sym`src`price`size!(2020.12.26D08:02:31.911000000;`ORCL;`;32.25;0Ni) 2020.12.26D09:12:37.087587000 `GOOG `N 45.55 98 q)t1,:(.z.p;`GOOG;`N;45.55;098) q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D08:00:13.099000000 IBM 43.52 2020.12.26D08:00:39.491000000 CSCO 35.45 2020.12.26D08:01:46.279000000 AAPL 25.34 2020.12.26D08:02:09.670000000 AAPL 25.37 2020.12.26D08:02:31.911000000 ORCL 32.25 2020.12.26D09:12:41.729632000 GOOG N 45.55 98 Horizontal Join ,' join each it adds extra columns to the right of existing table q)flip (enlist `side)!enlist 1000?`buy`sell // created new column side side ---- sell buy sell sell sell .. q)trades,'flip (enlist `side)!enlist 1000?`buy`sell time sym src price size side ------------------------------------------------------ 2020.12.26D08:00:13.099000000 IBM N 43.52 326 sell 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 buy 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 buy 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 buy 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 sell .. two table must have same number of rows, otherwise we would get 'length error q)count flip (enlist `side)!enlist 50?`buy`sell 50 q)trades,'flip (enlist `side)!enlist 50?`buy`sell 'length [0] trades,'flip (enlist `side)!enlist 50?`buy`sell Left Join lj joins 2 tables on the keyed columns of the right hand table right hand table must be a keyed table this can be used to add static data to a table q)voltrades:select vol:sum size by sym from trades q)voltrades sym | vol ----| ------ AAPL| 272375 CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 .. q)trades lj voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 272375 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 272375 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 .. if keyed table doesnt have values for each keyed column in left hand side table, then null data will be added for missing keys q)1_voltrades sym | vol ----| ------ CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 MSFT| 330837 .. q)trades lj 1_voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 .. joins can also be made for more than 1 columns q)voltrades2: select sum size by sym,src from trades q)voltrades2 sym src| size --------| ------ AAPL L | 110676 AAPL N | 56876 AAPL O | 104823 CSCO L | 122109 CSCO N | 75468 .. q)trades lj voltrades2 time sym src price size --------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 134448 2020.12.26D08:00:39.491000000 CSCO L 35.45 122109 2020.12.26D08:01:46.279000000 AAPL O 25.34 104823 2020.12.26D08:02:09.670000000 AAPL L 25.37 110676 2020.12.26D08:02:31.911000000 ORCL L 32.25 186353 .. Plus Join pj similar to a left join it will add the values in keyed table to the corresponding values in left-hand table if the value in the left hand table has no matching value in the keyed table, it will add 0 q)trades time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 .. q)correction:([sym:`AAPL`GOOG] price:.5 .5; changed:1 1) q)correction sym | price changed ----| ------------- AAPL| 0.5 1 GOOG| 0.5 1 q) q)trades pj correction time sym src price size changed --------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 0 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 0 2020.12.26D08:01:46.279000000 AAPL O 25.84 211 1 2020.12.26D08:02:09.670000000 AAPL L 25.87 8077 1 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 0 .. values in the keyed table must be compatible with addition q)correction:([sym:`AAPL`GOOG] price:.5 .5; changed:`y`y) q)correction sym | price changed ----| ------------- AAPL| 0.5 y GOOG| 0.5 y q)trades pj correction 'type [0] trades pj correction ^ q))\\ Inner Join ij inner join is similar to left join, however it will only return a value from left hand table if there is corresponding value in the keyed table only values present in both the table for each key are returned in left join, it would return all the rows from left table with null data joined even if there is no data in keyed table q)voltrades sym | vol ----| ------ AAPL| 272375 CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 .. q)voltrades2:2_voltrades q)voltrades2 sym | vol ----| ------ DELL| 274055 GOOG| 207724 IBM | 400192 MSFT| 330837 NOK | 215976 .. q)count trades lj voltrades2 1000 q)count trades ij voltrades2 788 q)trades ij voltrades2 time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 2020.12.26D08:02:40.066000000 ORCL N 32.22 4295 337317 2020.12.26D08:03:00.934000000 YHOO N 35.49 5339 320482 2020.12.26D08:03:29.198000000 ORCL L 32.25 2629 337317 .. q)trades lj voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 272375 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 272375 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 .. Union Join uj q) // setup q)\\l 2_where_clause_fakedb.q q)makedb[10000;1000] q)tables[] `depth`quotes`trades q)count trades 1000 q)count quotes 10000 can be keyed and unkeyed as well unkeyed - it will return a super set of all rows and all columns of both tables - missing values are filled with nulls q)t1:5#trades q)t2:5#quotes q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 q)t2 time sym src bid ask bsize asize -------------------------------------------------------------- 2020.12.26D08:00:02.809000000 MSFT L 36.08 36.09 8000 7500 2020.12.26D08:00:09.282000000 MSFT O 36.06 36.09 5500 8000 2020.12.26D08:00:10.075000000 IBM N 43.52 43.53 2500 4000 2020.12.26D08:00:10.646000000 YHOO L 35.49 35.5 7500 4500 2020.12.26D08:00:11.107000000 DELL N 29.05 29.09 2000 6000 q)t1 uj t2 time sym src price size bid ask bsize asize ------------------------------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 2020.12.26D08:00:02.809000000 MSFT L 36.08 36.09 8000 7500 2020.12.26D08:00:09.282000000 MSFT O 36.06 36.09 5500 8000 2020.12.26D08:00:10.075000000 IBM N 43.52 43.53 2500 4000 2020.12.26D08:00:10.646000000 YHOO L 35.49 35.5 7500 4500 2020.12.26D08:00:11.107000000 DELL N 29.05 29.09 2000 6000 keyed - rows from the left keyed table are updated with matches from right keyed table - if no match is found, then null data is added can be useful which are keyed by time example - we have table which has average mid price bucketed by 5 minute buckets q)tq: select avg .5*bid+ask by 5 xbar time.minute from quotes q)tt: select avg price by 5 xbar time.minute from trades where sym=`IBM q)tq minute| x ------| -------- 08:00 | 33.93856 08:05 | 35.3704 08:10 | 35.56701 08:15 | 34.212 08:20 | 33.9723 08:25 | 35.0075 08:30 | 34.20413 08:35 | 34.81067 08:40 | 35.19892 08:45 | 33.94478 08:50 | 35.65367 08:55 | 33.19094 09:00 | 35.1866 09:05 | 34.21341 09:10 | 34.51582 09:15 | 34.58091 09:20 | 34.29382 09:25 | 33.81271 09:30 | 33.77884 09:35 | 34.51159 .. q)tt minute| price ------| -------- 08:00 | 43.56333 08:10 | 43.55 08:15 | 43.54 08:20 | 43.56 08:30 | 43.7 08:35 | 43.62 08:40 | 43.63 08:50 | 43.56 09:05 | 43.515 09:15 | 43.43 09:25 | 43.42 09:30 | 43.49333 09:35 | 43.5 09:40 | 43.495 09:45 | 43.49 09:50 | 43.52 09:55 | 43.585 10:10 | 43.57 10:15 | 43.57 10:25 | 43.515 .. q)tq uj tt minute| x price ------| ----------------- 08:00 | 33.93856 43.56333 08:05 | 35.3704 08:10 | 35.56701 43.55 08:15 | 34.212 43.54 08:20 | 33.9723 43.56 08:25 | 35.0075 08:30 | 34.20413 43.7 08:35 | 34.81067 43.62 08:40 | 35.19892 43.63 08:45 | 33.94478 08:50 | 35.65367 43.56 08:55 | 33.19094 09:00 | 35.1866 09:05 | 34.21341 43.515 09:10 | 34.51582 09:15 | 34.58091 43.43 09:20 | 34.29382 09:25 | 33.81271 43.42 09:30 | 33.77884 43.49333 09:35 | 34.51159 43.5 .. we can fill the nulls with prev avg price if there are not trades during the bucket window q)fills tq uj tt minute| x price ------| ----------------- 08:00 | 33.93856 43.56333 08:05 | 35.3704 43.56333 08:10 | 35.56701 43.55 08:15 | 34.212 43.54 08:20 | 33.9723 43.56 08:25 | 35.0075 43.56 08:30 | 34.20413 43.7 08:35 | 34.81067 43.62 08:40 | 35.19892 43.63 08:45 | 33.94478 43.63 08:50 | 35.65367 43.56 08:55 | 33.19094 43.56 09:00 | 35.1866 43.56 09:05 | 34.21341 43.515 09:10 | 34.51582 43.515 09:15 | 34.58091 43.43 09:20 | 34.29382 43.43 09:25 | 33.81271 43.42 09:30 | 33.77884 43.49333 09:35 | 34.51159 43.5 ..","title":"Intro"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#joins","text":"q)// setup q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[1000;1000] q)tables[] `depth`quotes`trades","title":"Joins"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#vertical-join","text":"used to append 1 table at the end of another table q)t1:5#trades q)t2:-5#trades q)t1,t2 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D16:28:13.574000000 GOOG L 41.42 746 2020.12.26D16:28:51.196000000 NOK N 31.77 147 2020.12.26D16:28:56.993000000 CSCO O 35.51 6233 2020.12.26D16:29:05.901000000 AAPL L 25.32 64 2020.12.26D16:29:38.453000000 NOK N 31.81 307 columns of the 2 tables must match q)t1,5#quotes 'mismatch [0] t1,5#quotes ^ if we want to append subset of columns to table we must use ,: (join in-place) which will fill missing values with null q)t1,5#select time, sym, price from trades 'mismatch [0] t1,5#select time, sym, price from trades ^ q)t1,:5#select time, sym, price from trades q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D08:00:13.099000000 IBM 43.52 2020.12.26D08:00:39.491000000 CSCO 35.45 2020.12.26D08:01:46.279000000 AAPL 25.34 2020.12.26D08:02:09.670000000 AAPL 25.37 2020.12.26D08:02:31.911000000 ORCL 32.25 if we want to add single row of data, then also we must use join in-place( ,: ) q)t1,(.z.p;`GOOG;`N;45.55;098) `time`sym`src`price`size!(2020.12.26D08:00:13.099000000;`IBM;`N;43.52;326i) `time`sym`src`price`size!(2020.12.26D08:00:39.491000000;`CSCO;`L;35.45;2382i) `time`sym`src`price`size!(2020.12.26D08:01:46.279000000;`AAPL;`O;25.34;211i) `time`sym`src`price`size!(2020.12.26D08:02:09.670000000;`AAPL;`L;25.37;8077i) `time`sym`src`price`size!(2020.12.26D08:02:31.911000000;`ORCL;`L;32.25;5730i) `time`sym`src`price`size!(2020.12.26D08:00:13.099000000;`IBM;`;43.52;0Ni) `time`sym`src`price`size!(2020.12.26D08:00:39.491000000;`CSCO;`;35.45;0Ni) `time`sym`src`price`size!(2020.12.26D08:01:46.279000000;`AAPL;`;25.34;0Ni) `time`sym`src`price`size!(2020.12.26D08:02:09.670000000;`AAPL;`;25.37;0Ni) `time`sym`src`price`size!(2020.12.26D08:02:31.911000000;`ORCL;`;32.25;0Ni) 2020.12.26D09:12:37.087587000 `GOOG `N 45.55 98 q)t1,:(.z.p;`GOOG;`N;45.55;098) q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 2020.12.26D08:00:13.099000000 IBM 43.52 2020.12.26D08:00:39.491000000 CSCO 35.45 2020.12.26D08:01:46.279000000 AAPL 25.34 2020.12.26D08:02:09.670000000 AAPL 25.37 2020.12.26D08:02:31.911000000 ORCL 32.25 2020.12.26D09:12:41.729632000 GOOG N 45.55 98","title":"Vertical Join ,"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#horizontal-join","text":"join each it adds extra columns to the right of existing table q)flip (enlist `side)!enlist 1000?`buy`sell // created new column side side ---- sell buy sell sell sell .. q)trades,'flip (enlist `side)!enlist 1000?`buy`sell time sym src price size side ------------------------------------------------------ 2020.12.26D08:00:13.099000000 IBM N 43.52 326 sell 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 buy 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 buy 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 buy 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 sell .. two table must have same number of rows, otherwise we would get 'length error q)count flip (enlist `side)!enlist 50?`buy`sell 50 q)trades,'flip (enlist `side)!enlist 50?`buy`sell 'length [0] trades,'flip (enlist `side)!enlist 50?`buy`sell","title":"Horizontal Join ,'"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#left-join-lj","text":"joins 2 tables on the keyed columns of the right hand table right hand table must be a keyed table this can be used to add static data to a table q)voltrades:select vol:sum size by sym from trades q)voltrades sym | vol ----| ------ AAPL| 272375 CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 .. q)trades lj voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 272375 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 272375 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 .. if keyed table doesnt have values for each keyed column in left hand side table, then null data will be added for missing keys q)1_voltrades sym | vol ----| ------ CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 MSFT| 330837 .. q)trades lj 1_voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 .. joins can also be made for more than 1 columns q)voltrades2: select sum size by sym,src from trades q)voltrades2 sym src| size --------| ------ AAPL L | 110676 AAPL N | 56876 AAPL O | 104823 CSCO L | 122109 CSCO N | 75468 .. q)trades lj voltrades2 time sym src price size --------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 134448 2020.12.26D08:00:39.491000000 CSCO L 35.45 122109 2020.12.26D08:01:46.279000000 AAPL O 25.34 104823 2020.12.26D08:02:09.670000000 AAPL L 25.37 110676 2020.12.26D08:02:31.911000000 ORCL L 32.25 186353 ..","title":"Left Join lj"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#plus-join-pj","text":"similar to a left join it will add the values in keyed table to the corresponding values in left-hand table if the value in the left hand table has no matching value in the keyed table, it will add 0 q)trades time sym src price size ------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 .. q)correction:([sym:`AAPL`GOOG] price:.5 .5; changed:1 1) q)correction sym | price changed ----| ------------- AAPL| 0.5 1 GOOG| 0.5 1 q) q)trades pj correction time sym src price size changed --------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 0 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 0 2020.12.26D08:01:46.279000000 AAPL O 25.84 211 1 2020.12.26D08:02:09.670000000 AAPL L 25.87 8077 1 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 0 .. values in the keyed table must be compatible with addition q)correction:([sym:`AAPL`GOOG] price:.5 .5; changed:`y`y) q)correction sym | price changed ----| ------------- AAPL| 0.5 y GOOG| 0.5 y q)trades pj correction 'type [0] trades pj correction ^ q))\\","title":"Plus Join pj"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#inner-join-ij","text":"inner join is similar to left join, however it will only return a value from left hand table if there is corresponding value in the keyed table only values present in both the table for each key are returned in left join, it would return all the rows from left table with null data joined even if there is no data in keyed table q)voltrades sym | vol ----| ------ AAPL| 272375 CSCO| 295679 DELL| 274055 GOOG| 207724 IBM | 400192 .. q)voltrades2:2_voltrades q)voltrades2 sym | vol ----| ------ DELL| 274055 GOOG| 207724 IBM | 400192 MSFT| 330837 NOK | 215976 .. q)count trades lj voltrades2 1000 q)count trades ij voltrades2 788 q)trades ij voltrades2 time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 2020.12.26D08:02:40.066000000 ORCL N 32.22 4295 337317 2020.12.26D08:03:00.934000000 YHOO N 35.49 5339 320482 2020.12.26D08:03:29.198000000 ORCL L 32.25 2629 337317 .. q)trades lj voltrades time sym src price size vol -------------------------------------------------------- 2020.12.26D08:00:13.099000000 IBM N 43.52 326 400192 2020.12.26D08:00:39.491000000 CSCO L 35.45 2382 295679 2020.12.26D08:01:46.279000000 AAPL O 25.34 211 272375 2020.12.26D08:02:09.670000000 AAPL L 25.37 8077 272375 2020.12.26D08:02:31.911000000 ORCL L 32.25 5730 337317 ..","title":"Inner Join ij"},{"location":"kdb-q/keywords_joins_adverbs_attributes/2_joins/#union-join-uj","text":"q) // setup q)\\l 2_where_clause_fakedb.q q)makedb[10000;1000] q)tables[] `depth`quotes`trades q)count trades 1000 q)count quotes 10000 can be keyed and unkeyed as well unkeyed - it will return a super set of all rows and all columns of both tables - missing values are filled with nulls q)t1:5#trades q)t2:5#quotes q)t1 time sym src price size ------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 q)t2 time sym src bid ask bsize asize -------------------------------------------------------------- 2020.12.26D08:00:02.809000000 MSFT L 36.08 36.09 8000 7500 2020.12.26D08:00:09.282000000 MSFT O 36.06 36.09 5500 8000 2020.12.26D08:00:10.075000000 IBM N 43.52 43.53 2500 4000 2020.12.26D08:00:10.646000000 YHOO L 35.49 35.5 7500 4500 2020.12.26D08:00:11.107000000 DELL N 29.05 29.09 2000 6000 q)t1 uj t2 time sym src price size bid ask bsize asize ------------------------------------------------------------------------- 2020.12.26D08:00:17.350000000 CSCO N 35.46 2367 2020.12.26D08:00:30.245000000 DELL N 29.05 27 2020.12.26D08:01:40.842000000 AAPL L 25.37 2797 2020.12.26D08:02:11.579000000 CSCO L 35.46 1714 2020.12.26D08:02:12.246000000 YHOO N 35.5 166 2020.12.26D08:00:02.809000000 MSFT L 36.08 36.09 8000 7500 2020.12.26D08:00:09.282000000 MSFT O 36.06 36.09 5500 8000 2020.12.26D08:00:10.075000000 IBM N 43.52 43.53 2500 4000 2020.12.26D08:00:10.646000000 YHOO L 35.49 35.5 7500 4500 2020.12.26D08:00:11.107000000 DELL N 29.05 29.09 2000 6000 keyed - rows from the left keyed table are updated with matches from right keyed table - if no match is found, then null data is added can be useful which are keyed by time example - we have table which has average mid price bucketed by 5 minute buckets q)tq: select avg .5*bid+ask by 5 xbar time.minute from quotes q)tt: select avg price by 5 xbar time.minute from trades where sym=`IBM q)tq minute| x ------| -------- 08:00 | 33.93856 08:05 | 35.3704 08:10 | 35.56701 08:15 | 34.212 08:20 | 33.9723 08:25 | 35.0075 08:30 | 34.20413 08:35 | 34.81067 08:40 | 35.19892 08:45 | 33.94478 08:50 | 35.65367 08:55 | 33.19094 09:00 | 35.1866 09:05 | 34.21341 09:10 | 34.51582 09:15 | 34.58091 09:20 | 34.29382 09:25 | 33.81271 09:30 | 33.77884 09:35 | 34.51159 .. q)tt minute| price ------| -------- 08:00 | 43.56333 08:10 | 43.55 08:15 | 43.54 08:20 | 43.56 08:30 | 43.7 08:35 | 43.62 08:40 | 43.63 08:50 | 43.56 09:05 | 43.515 09:15 | 43.43 09:25 | 43.42 09:30 | 43.49333 09:35 | 43.5 09:40 | 43.495 09:45 | 43.49 09:50 | 43.52 09:55 | 43.585 10:10 | 43.57 10:15 | 43.57 10:25 | 43.515 .. q)tq uj tt minute| x price ------| ----------------- 08:00 | 33.93856 43.56333 08:05 | 35.3704 08:10 | 35.56701 43.55 08:15 | 34.212 43.54 08:20 | 33.9723 43.56 08:25 | 35.0075 08:30 | 34.20413 43.7 08:35 | 34.81067 43.62 08:40 | 35.19892 43.63 08:45 | 33.94478 08:50 | 35.65367 43.56 08:55 | 33.19094 09:00 | 35.1866 09:05 | 34.21341 43.515 09:10 | 34.51582 09:15 | 34.58091 43.43 09:20 | 34.29382 09:25 | 33.81271 43.42 09:30 | 33.77884 43.49333 09:35 | 34.51159 43.5 .. we can fill the nulls with prev avg price if there are not trades during the bucket window q)fills tq uj tt minute| x price ------| ----------------- 08:00 | 33.93856 43.56333 08:05 | 35.3704 43.56333 08:10 | 35.56701 43.55 08:15 | 34.212 43.54 08:20 | 33.9723 43.56 08:25 | 35.0075 43.56 08:30 | 34.20413 43.7 08:35 | 34.81067 43.62 08:40 | 35.19892 43.63 08:45 | 33.94478 43.63 08:50 | 35.65367 43.56 08:55 | 33.19094 43.56 09:00 | 35.1866 43.56 09:05 | 34.21341 43.515 09:10 | 34.51582 43.515 09:15 | 34.58091 43.43 09:20 | 34.29382 43.43 09:25 | 33.81271 43.42 09:30 | 33.77884 43.49333 09:35 | 34.51159 43.5 ..","title":"Union Join uj"},{"location":"kdb-q/keywords_joins_adverbs_attributes/3_asof_window_joins/","text":"asof and window join q) // setup q)\\l 2_where_clause_fakedb.q q)makedb[50000;10000] q)tables[] `depth`quotes`trades q)count quotes 50000 q)count trades 10000 there are many more quotes than trades we want to find quotes just before the trade took place for each sym As of Join aj aj0 format : aj[c1..cn;table1;table2] cn : column on which as-of-join is performed, most recent time from t2 which is asof(<=) time in table1 c1..cn-1 : columns are matched exactly in table1 and table2 aj will have all columns from table1 and values of columns c1..cn are from table1 and value from table2 will have matching values q)select from aj[`sym`time;trades;quotes] where sym=`AAPL time sym src price size bid ask bsize asize ------------------------------------------------------------------------- 2020.12.26D08:00:03.057000000 AAPL L 25.33 4527 25.33 25.37 9000 3000 2020.12.26D08:00:12.190000000 AAPL O 25.38 1889 25.35 25.38 4000 7000 2020.12.26D08:01:22.084000000 AAPL L 25.37 5413 25.35 25.37 6000 5500 2020.12.26D08:02:12.686000000 AAPL O 25.33 1841 25.32 25.33 4000 5000 2020.12.26D08:02:59.207000000 AAPL N 25.32 957 25.32 25.36 1500 6500 2020.12.26D08:03:04.870000000 AAPL N 25.34 991 25.32 25.34 3000 1000 2020.12.26D08:03:05.194000000 AAPL N 25.34 454 25.32 25.34 3000 1000 2020.12.26D08:03:50.205000000 AAPL N 25.34 176 25.31 25.34 1500 2000 2020.12.26D08:03:52.988000000 AAPL N 25.34 491 25.31 25.34 1500 2000 2020.12.26D08:04:00.136000000 AAPL L 25.35 4392 25.32 25.35 1000 5500 2020.12.26D08:04:14.266000000 AAPL N 25.32 530 25.32 25.33 5500 9000 2020.12.26D08:05:16.333000000 AAPL L 25.35 1118 25.33 25.35 7000 6000 2020.12.26D08:06:36.068000000 AAPL L 25.33 1321 25.33 25.33 5500 6000 2020.12.26D08:06:46.472000000 AAPL L 25.33 1973 25.33 25.35 2500 8500 2020.12.26D08:07:40.059000000 AAPL O 25.36 4447 25.36 25.4 10000 500 2020.12.26D08:08:01.875000000 AAPL N 25.37 4330 25.37 25.42 7500 10000 2020.12.26D08:08:07.323000000 AAPL N 25.42 3511 25.37 25.42 7500 10000 2020.12.26D08:08:11.894000000 AAPL N 25.37 4588 25.37 25.42 7500 10000 2020.12.26D08:08:16.016000000 AAPL N 25.37 3810 25.37 25.42 7500 10000 2020.12.26D08:08:25.522000000 AAPL N 25.37 2264 25.37 25.42 7500 10000 .. q)select from quotes where sym=`AAPL time sym src bid ask bsize asize -------------------------------------------------------------- 2020.12.26D08:00:02.705000000 AAPL N 25.32 25.37 6500 1000 2020.12.26D08:00:02.882000000 AAPL L 25.33 25.37 9000 3000 2020.12.26D08:00:04.111000000 AAPL L 25.33 25.37 9500 7000 2020.12.26D08:00:05.040000000 AAPL L 25.35 25.37 2500 9500 2020.12.26D08:00:09.235000000 AAPL N 25.35 25.37 4000 6500 2020.12.26D08:00:10.576000000 AAPL O 25.35 25.38 4000 7000 2020.12.26D08:00:16.432000000 AAPL O 25.35 25.39 3000 10000 2020.12.26D08:00:25.528000000 AAPL N 25.35 25.37 3000 4000 2020.12.26D08:00:26.237000000 AAPL N 25.34 25.37 6000 9000 2020.12.26D08:00:32.058000000 AAPL L 25.35 25.38 3000 4000 2020.12.26D08:00:47.294000000 AAPL L 25.34 25.36 9500 2500 2020.12.26D08:01:06.551000000 AAPL N 25.35 25.38 4500 2500 2020.12.26D08:01:08.708000000 AAPL N 25.32 25.37 9000 7500 2020.12.26D08:01:16.411000000 AAPL L 25.35 25.37 6000 5500 2020.12.26D08:01:25.050000000 AAPL L 25.34 25.37 500 5500 2020.12.26D08:01:33.147000000 AAPL N 25.35 25.36 6500 5000 2020.12.26D08:01:46.838000000 AAPL L 25.34 25.37 2500 4500 2020.12.26D08:01:47.149000000 AAPL L 25.32 25.35 3000 5500 2020.12.26D08:01:48.825000000 AAPL N 25.33 25.36 500 7000 2020.12.26D08:01:59.163000000 AAPL L 25.35 25.36 5000 500 .. query performance will matter a lot if join columns c1..cn has grouped( g# ) attribute set for in-memory tables and parted( p# ) attribute set for on-disk tables q)\\t aj[`sym`time;trades;quotes] 12 q)meta quotes c | t f a -----| ----- time | p sym | s g src | s g bid | f ask | f bsize| i asize| i q)meta trades c | t f a -----| ----- time | p sym | s g src | s g price| f size | i q)update `#sym from `quotes `quotes q)\\t aj[`sym`time;trades;quotes] 5805 aj0 will used if in result table we want to show values for column cn from table2 aj in hdb main difference with on-disk tables is we would have to load them in-memory first while loading parted attribute p# is lost - workaroun : load data for each date and raze them into 1 table - which will preserve parted attributes Window Join wj wj0 in aj we would get last value/most-recent value in wj we can specify our window and also aggregation function which would be applied on joined data format: wj[w; c; t; (q; (f0;c0); (f1;c1))] t and q are tables w is pair of lists of times/timestamps, begin and end c are the common columns f0 , f1 are aggregate function applied to values in q columns c0 and c1 over the intervals returns for each record in t , a record with additional columns c0 and c1 , which are the results of the aggregation functions applied to values over the matching intervals in w . aj is a special case of wj or wj is generalized form of aj exact match columns c needs to have attribute #p or #g applied to them, other wise query would be much slower and also might give wrong results as well q)w: -1000 1000+\\:trades.time q)w 08:00:02.057 08:00:03.230 08:00:10.150 08:00:11.190 08:00:11.531 08:00:14.312.. 08:00:04.057 08:00:05.230 08:00:12.150 08:00:13.190 08:00:13.531 08:00:16.312.. q)\\t wj[w; `sym`time;trades;(quotes; (max;`bid);(min;`ask))] 61 q)wj[w; `sym`time;trades;(quotes; (max;`bid);(min;`ask))] time sym src price size bid ask -------------------------------------------- 08:00:03.057 AAPL L 25.33 4527 25.33 25.37 08:00:04.230 YHOO N 35.49 1457 35.49 35.52 08:00:11.150 DELL L 29.08 6788 43.53 25.38 08:00:12.190 AAPL O 25.38 1889 25.35 25.38 08:00:12.531 MSFT L 36.08 4974 36.08 36.11 08:00:15.312 ORCL O 32.2 668 43.53 25.37 08:00:24.269 ORCL L 32.23 1116 32.19 32.23 08:00:29.856 MSFT L 36.13 766 36.1 36.13 08:00:33.033 ORCL L 32.23 1749 43.54 25.37 08:00:33.126 ORCL L 32.19 1394 43.54 25.37 08:00:40.441 MSFT L 36.12 1151 36.12 36.13 08:00:46.699 IBM N 43.57 1958 43.55 43.57 08:00:49.597 CSCO L 35.46 2164 35.46 35.49 08:00:51.534 CSCO L 35.46 2762 35.46 35.49 08:00:56.880 YHOO N 35.52 227 35.49 35.52 08:00:57.649 MSFT L 36.13 2028 36.08 36.13 08:00:58.363 CSCO O 35.49 2273 35.45 35.49 08:01:00.037 DELL L 29.06 3260 29.04 29.06 08:01:04.382 NOK O 31.79 3765 31.79 31.83 08:01:06.810 IBM N 43.55 4224 43.55 25.36 ..","title":"Asof-Windows"},{"location":"kdb-q/keywords_joins_adverbs_attributes/3_asof_window_joins/#asof-and-window-join","text":"q) // setup q)\\l 2_where_clause_fakedb.q q)makedb[50000;10000] q)tables[] `depth`quotes`trades q)count quotes 50000 q)count trades 10000 there are many more quotes than trades we want to find quotes just before the trade took place for each sym","title":"asof and window join"},{"location":"kdb-q/keywords_joins_adverbs_attributes/3_asof_window_joins/#as-of-join-aj-aj0","text":"format : aj[c1..cn;table1;table2] cn : column on which as-of-join is performed, most recent time from t2 which is asof(<=) time in table1 c1..cn-1 : columns are matched exactly in table1 and table2 aj will have all columns from table1 and values of columns c1..cn are from table1 and value from table2 will have matching values q)select from aj[`sym`time;trades;quotes] where sym=`AAPL time sym src price size bid ask bsize asize ------------------------------------------------------------------------- 2020.12.26D08:00:03.057000000 AAPL L 25.33 4527 25.33 25.37 9000 3000 2020.12.26D08:00:12.190000000 AAPL O 25.38 1889 25.35 25.38 4000 7000 2020.12.26D08:01:22.084000000 AAPL L 25.37 5413 25.35 25.37 6000 5500 2020.12.26D08:02:12.686000000 AAPL O 25.33 1841 25.32 25.33 4000 5000 2020.12.26D08:02:59.207000000 AAPL N 25.32 957 25.32 25.36 1500 6500 2020.12.26D08:03:04.870000000 AAPL N 25.34 991 25.32 25.34 3000 1000 2020.12.26D08:03:05.194000000 AAPL N 25.34 454 25.32 25.34 3000 1000 2020.12.26D08:03:50.205000000 AAPL N 25.34 176 25.31 25.34 1500 2000 2020.12.26D08:03:52.988000000 AAPL N 25.34 491 25.31 25.34 1500 2000 2020.12.26D08:04:00.136000000 AAPL L 25.35 4392 25.32 25.35 1000 5500 2020.12.26D08:04:14.266000000 AAPL N 25.32 530 25.32 25.33 5500 9000 2020.12.26D08:05:16.333000000 AAPL L 25.35 1118 25.33 25.35 7000 6000 2020.12.26D08:06:36.068000000 AAPL L 25.33 1321 25.33 25.33 5500 6000 2020.12.26D08:06:46.472000000 AAPL L 25.33 1973 25.33 25.35 2500 8500 2020.12.26D08:07:40.059000000 AAPL O 25.36 4447 25.36 25.4 10000 500 2020.12.26D08:08:01.875000000 AAPL N 25.37 4330 25.37 25.42 7500 10000 2020.12.26D08:08:07.323000000 AAPL N 25.42 3511 25.37 25.42 7500 10000 2020.12.26D08:08:11.894000000 AAPL N 25.37 4588 25.37 25.42 7500 10000 2020.12.26D08:08:16.016000000 AAPL N 25.37 3810 25.37 25.42 7500 10000 2020.12.26D08:08:25.522000000 AAPL N 25.37 2264 25.37 25.42 7500 10000 .. q)select from quotes where sym=`AAPL time sym src bid ask bsize asize -------------------------------------------------------------- 2020.12.26D08:00:02.705000000 AAPL N 25.32 25.37 6500 1000 2020.12.26D08:00:02.882000000 AAPL L 25.33 25.37 9000 3000 2020.12.26D08:00:04.111000000 AAPL L 25.33 25.37 9500 7000 2020.12.26D08:00:05.040000000 AAPL L 25.35 25.37 2500 9500 2020.12.26D08:00:09.235000000 AAPL N 25.35 25.37 4000 6500 2020.12.26D08:00:10.576000000 AAPL O 25.35 25.38 4000 7000 2020.12.26D08:00:16.432000000 AAPL O 25.35 25.39 3000 10000 2020.12.26D08:00:25.528000000 AAPL N 25.35 25.37 3000 4000 2020.12.26D08:00:26.237000000 AAPL N 25.34 25.37 6000 9000 2020.12.26D08:00:32.058000000 AAPL L 25.35 25.38 3000 4000 2020.12.26D08:00:47.294000000 AAPL L 25.34 25.36 9500 2500 2020.12.26D08:01:06.551000000 AAPL N 25.35 25.38 4500 2500 2020.12.26D08:01:08.708000000 AAPL N 25.32 25.37 9000 7500 2020.12.26D08:01:16.411000000 AAPL L 25.35 25.37 6000 5500 2020.12.26D08:01:25.050000000 AAPL L 25.34 25.37 500 5500 2020.12.26D08:01:33.147000000 AAPL N 25.35 25.36 6500 5000 2020.12.26D08:01:46.838000000 AAPL L 25.34 25.37 2500 4500 2020.12.26D08:01:47.149000000 AAPL L 25.32 25.35 3000 5500 2020.12.26D08:01:48.825000000 AAPL N 25.33 25.36 500 7000 2020.12.26D08:01:59.163000000 AAPL L 25.35 25.36 5000 500 .. query performance will matter a lot if join columns c1..cn has grouped( g# ) attribute set for in-memory tables and parted( p# ) attribute set for on-disk tables q)\\t aj[`sym`time;trades;quotes] 12 q)meta quotes c | t f a -----| ----- time | p sym | s g src | s g bid | f ask | f bsize| i asize| i q)meta trades c | t f a -----| ----- time | p sym | s g src | s g price| f size | i q)update `#sym from `quotes `quotes q)\\t aj[`sym`time;trades;quotes] 5805 aj0 will used if in result table we want to show values for column cn from table2","title":"As of Join aj aj0"},{"location":"kdb-q/keywords_joins_adverbs_attributes/3_asof_window_joins/#aj-in-hdb","text":"main difference with on-disk tables is we would have to load them in-memory first while loading parted attribute p# is lost - workaroun : load data for each date and raze them into 1 table - which will preserve parted attributes","title":"aj in hdb"},{"location":"kdb-q/keywords_joins_adverbs_attributes/3_asof_window_joins/#window-join-wj-wj0","text":"in aj we would get last value/most-recent value in wj we can specify our window and also aggregation function which would be applied on joined data format: wj[w; c; t; (q; (f0;c0); (f1;c1))] t and q are tables w is pair of lists of times/timestamps, begin and end c are the common columns f0 , f1 are aggregate function applied to values in q columns c0 and c1 over the intervals returns for each record in t , a record with additional columns c0 and c1 , which are the results of the aggregation functions applied to values over the matching intervals in w . aj is a special case of wj or wj is generalized form of aj exact match columns c needs to have attribute #p or #g applied to them, other wise query would be much slower and also might give wrong results as well q)w: -1000 1000+\\:trades.time q)w 08:00:02.057 08:00:03.230 08:00:10.150 08:00:11.190 08:00:11.531 08:00:14.312.. 08:00:04.057 08:00:05.230 08:00:12.150 08:00:13.190 08:00:13.531 08:00:16.312.. q)\\t wj[w; `sym`time;trades;(quotes; (max;`bid);(min;`ask))] 61 q)wj[w; `sym`time;trades;(quotes; (max;`bid);(min;`ask))] time sym src price size bid ask -------------------------------------------- 08:00:03.057 AAPL L 25.33 4527 25.33 25.37 08:00:04.230 YHOO N 35.49 1457 35.49 35.52 08:00:11.150 DELL L 29.08 6788 43.53 25.38 08:00:12.190 AAPL O 25.38 1889 25.35 25.38 08:00:12.531 MSFT L 36.08 4974 36.08 36.11 08:00:15.312 ORCL O 32.2 668 43.53 25.37 08:00:24.269 ORCL L 32.23 1116 32.19 32.23 08:00:29.856 MSFT L 36.13 766 36.1 36.13 08:00:33.033 ORCL L 32.23 1749 43.54 25.37 08:00:33.126 ORCL L 32.19 1394 43.54 25.37 08:00:40.441 MSFT L 36.12 1151 36.12 36.13 08:00:46.699 IBM N 43.57 1958 43.55 43.57 08:00:49.597 CSCO L 35.46 2164 35.46 35.49 08:00:51.534 CSCO L 35.46 2762 35.46 35.49 08:00:56.880 YHOO N 35.52 227 35.49 35.52 08:00:57.649 MSFT L 36.13 2028 36.08 36.13 08:00:58.363 CSCO O 35.49 2273 35.45 35.49 08:01:00.037 DELL L 29.06 3260 29.04 29.06 08:01:04.382 NOK O 31.79 3765 31.79 31.83 08:01:06.810 IBM N 43.55 4224 43.55 25.36 ..","title":"Window Join wj wj0"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/","text":"Adverbs used generally to apply a function over a list each ' used to apply a function to each individual element of a list q) //function to count number of divisors of a number q) divisors:{count where 0=x mod 1+til x} q) //works fine with atomic values q)divisors 5 2 q)divisors 10 4 q)divisors 20 6 q) //doesn't work with list q)l 12 10 1 90 73 90 43 90 84 63 93 54 38 97 88 58 68 45 2 39 q)divisors l 'type [2] (.q.til) [1] divisors:{count where 0=x mod 1+til x} q) //we use each to execute divisors function over each element of list q)divisors each l 6 4 1 12 2 12 2 12 12 6 4 8 4 2 8 4 6 6 2 4 also used for nested lists q)(2 3 4 5; 9 8; 9 8 3 4 56) 2 3 4 5 9 8 9 8 3 4 56 q)count (2 3 4 5; 9 8; 9 8 3 4 56) 3 q)count each (2 3 4 5; 9 8; 9 8 3 4 56) 4 2 5 q)reverse each (2 3 4 5; 9 8; 9 8 3 4 56) 5 4 3 2 8 9 56 4 3 8 9 q)reverse (2 3 4 5; 9 8; 9 8 3 4 56) 9 8 3 4 56 9 8 2 3 4 5 each-both ,' it is polyadic form of each often used for applying diadic function element wise to a pair of lists q)l1 45 84 97 45 38 q)l2 12 45 88 63 2 q)l1,'l2 45 12 84 45 97 88 45 63 38 2 q)l1,l2 45 84 97 45 38 12 45 88 63 2 each-both can also be applied to higher valency functions q){x,y,z}'[1 2 3;\"abc\";1.1 2.2 3.3] 1 \"a\" 1.1 2 \"b\" 2.2 3 \"c\" 3.3 each-right /: used with diadic function where we want to use a list as right-hand argument join each right hand arguments to left hand argument iterate over right q)l:1 2 3 q)l,/:10 20 30 1 2 3 10 1 2 3 20 1 2 3 30 each-left \\: used with diadic function where we want to use a list as right-hand argument join each left hand argument to right hand argument iterate over left q)l:1 2 3 q)l,\\:10 20 30 1 10 20 30 2 10 20 30 3 10 20 30 many inbuilt operator already works on list and atom in same manner - thus if we get desired result with such operators we shouldn't be using adverbs with them q)10 + 1 2 3 11 12 13 q)10 +/: 1 2 3 11 12 13 each-prior ': used to apply a diadic function to a list element and its predecessor in the list q)// sum each prior - running sum q)l 1 2 3 q)+':[l] 1 3 5 can also be used to show each element of list alongside its predecessor q){x,y}':[l] 1 2 1 3 2 we can also use optional first parameter - which will be used as first y argument in the function q){x,y}':[0;l] 1 0 2 1 3 2 q){x,y}':[10;l] 1 10 2 1 3 2 deltas is -': minus each prior q)deltas -': q)deltas l 1 1 1 q)-':[l] 1 1 1 q) scan \\ , over / little complicated their behavior depends on valency of function also on data type of arguments scan returns results after each iteration of f , over returns result only once after result is converged monadic function - f f\\[n;x] - returns f{x} , f{f{x}} and so on n times q){x+7}\\[10;0] // add 7, 10 times, starting with 0 0 7 14 21 28 35 42 49 56 63 70 q){x+7}\\[10;5] // add 7, 10 times, starting with 5 5 12 19 26 33 40 47 54 61 68 75 q){x+7}/[10;5] // add 7, 10 times, starting with 5, over-only shows end result 75 we can also use while clause instead of integer n q){x+7}\\[{x<100};5] // add 7, while result <100, starting with 5 5 12 19 26 33 40 47 54 61 68 75 82 89 96 103 f/[x] - if n is not provided, iterate till output is same as previous result, or till last 2 results are same f\\[x] - iterate(scan) and f/[x] - converge(over) q){x%10}/[5] 0f q) q){x%10}\\[5] 5 0.5 0.05 0.005 0.0005 5e-005 5e-006 5e-007 5e-008 dyadic function - f function takes 2 arguments f\\[a b c d] = a; f[a;b] f[f[a;b];c] ... or we can also provide initial number x - f\\[x;a b c d] = 100+a; 100+f[a;b]; 100+f[f[a;b];c] .. q)til 20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 q)+\\[til 20] 0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 q)+\\[100;til 20] 100 101 103 106 110 115 121 128 136 145 155 166 178 191 205 220 236 253 271 290 Exercise calculate depreciation of an asset over time function : depr:{[c;r] c*1-r%100} depreciation in 1 year q)depr[1000;10] // starting cost=1000, rate=10% 900f depreciation in 5 years or x years q)depr[;10]\\[5;1000] // starting cost=1000, rate=10%, over 5 years, using monadic version by keeping rate constant 1000 900f 810f 729f 656.1 590.49 check with different rate q)depr\\[1000;3 5 6 8 10] // cost=1000, rates=3 5 6 8 10% 970 921.5 866.21 796.9132 717.2219 different rate, different cost, 1 year q)depr\\[1000 2000 5000 10000;3 5 6 8 10] // cost=1000 2000 5000 10000, rates=3 5 6 8 10% 970 1940 4850 9700 921.5 1843 4607.5 9215 866.21 1732.42 4331.05 8662.1 796.9132 1593.826 3984.566 7969.132 717.2219 1434.444 3586.109 7172.219 Exercise: Question: Suppose we are given a vector of numbers (xx) and a step size (s). Write a function that will take x and s as arguments, and output a result vector. The result vector is constructed using the following procedure: 1. The xx value sets the mid-point of the step (e.g. if xx is 1 and s is 3, then the values -1,0,1,2 and 3 are included in that step range) 2. If the next xx value is within the current step range, then the step mid-point does not change (e.g. if xx is -1, then the step mid-point is still 1) 3. If the next xx value falls outside the current step range, the step mid-point is reset to that xx value (e.g. if xx is 4, then the new step mid-point is 4) 4. The current step mid-point is stored each time in the result vector Here are two examples to clarify the procedure: xx:1 -1 3 0 1 1 5 6 2 10 s:3 result:1 1 1 1 1 1 5 5 2 10 and xx:2 3 4 3 20 7 8 31 s:6 result:2 2 2 2 20 7 7 31 Answer: We will need to introduce 3 parameters: 1. x - the step size (this will take the value s) 2. y - the current step mid-point 3. z - the next value in the xx vector (we will see later how this may be achieved with an adverb) If z is within the current step range, it will satisfy: y - x < z < y + x ; this can be rearranged to give: x > abs ( z - y) So, if x>abs(z-y) is true, then the step mid-point does not change, and the value of y should be saved to the result vector. Alternatively, if x>abs(z-y) is false, then the step mid-point will change to the value of z, and so z should be saved to the result vector. The previous two comments can be expressed as an if-else statement: $[x>abs z - y; y; z] /the value returned, will be the step mid-point Let's digress back to the scan function e.g. q){x+y}\\[1 2 3 4] 1 3 6 10 The value returned by the above function is used as the next x value, and the next y value is taken from the next item in the list. This is exactly what we need to do in our problem. Thus, the solution is given by: {$[x>abs z - y; y; z]}[s]\\[xx]","title":"Adverbs"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#adverbs","text":"used generally to apply a function over a list","title":"Adverbs"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#each","text":"used to apply a function to each individual element of a list q) //function to count number of divisors of a number q) divisors:{count where 0=x mod 1+til x} q) //works fine with atomic values q)divisors 5 2 q)divisors 10 4 q)divisors 20 6 q) //doesn't work with list q)l 12 10 1 90 73 90 43 90 84 63 93 54 38 97 88 58 68 45 2 39 q)divisors l 'type [2] (.q.til) [1] divisors:{count where 0=x mod 1+til x} q) //we use each to execute divisors function over each element of list q)divisors each l 6 4 1 12 2 12 2 12 12 6 4 8 4 2 8 4 6 6 2 4 also used for nested lists q)(2 3 4 5; 9 8; 9 8 3 4 56) 2 3 4 5 9 8 9 8 3 4 56 q)count (2 3 4 5; 9 8; 9 8 3 4 56) 3 q)count each (2 3 4 5; 9 8; 9 8 3 4 56) 4 2 5 q)reverse each (2 3 4 5; 9 8; 9 8 3 4 56) 5 4 3 2 8 9 56 4 3 8 9 q)reverse (2 3 4 5; 9 8; 9 8 3 4 56) 9 8 3 4 56 9 8 2 3 4 5","title":"each '"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#each-both","text":"it is polyadic form of each often used for applying diadic function element wise to a pair of lists q)l1 45 84 97 45 38 q)l2 12 45 88 63 2 q)l1,'l2 45 12 84 45 97 88 45 63 38 2 q)l1,l2 45 84 97 45 38 12 45 88 63 2 each-both can also be applied to higher valency functions q){x,y,z}'[1 2 3;\"abc\";1.1 2.2 3.3] 1 \"a\" 1.1 2 \"b\" 2.2 3 \"c\" 3.3","title":"each-both ,'"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#each-right","text":"used with diadic function where we want to use a list as right-hand argument join each right hand arguments to left hand argument iterate over right q)l:1 2 3 q)l,/:10 20 30 1 2 3 10 1 2 3 20 1 2 3 30","title":"each-right /:"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#each-left","text":"used with diadic function where we want to use a list as right-hand argument join each left hand argument to right hand argument iterate over left q)l:1 2 3 q)l,\\:10 20 30 1 10 20 30 2 10 20 30 3 10 20 30 many inbuilt operator already works on list and atom in same manner - thus if we get desired result with such operators we shouldn't be using adverbs with them q)10 + 1 2 3 11 12 13 q)10 +/: 1 2 3 11 12 13","title":"each-left \\:"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#each-prior","text":"used to apply a diadic function to a list element and its predecessor in the list q)// sum each prior - running sum q)l 1 2 3 q)+':[l] 1 3 5 can also be used to show each element of list alongside its predecessor q){x,y}':[l] 1 2 1 3 2 we can also use optional first parameter - which will be used as first y argument in the function q){x,y}':[0;l] 1 0 2 1 3 2 q){x,y}':[10;l] 1 10 2 1 3 2 deltas is -': minus each prior q)deltas -': q)deltas l 1 1 1 q)-':[l] 1 1 1 q)","title":"each-prior ':"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#scan-over","text":"little complicated their behavior depends on valency of function also on data type of arguments scan returns results after each iteration of f , over returns result only once after result is converged","title":"scan \\ , over /"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#monadic-function-f","text":"f\\[n;x] - returns f{x} , f{f{x}} and so on n times q){x+7}\\[10;0] // add 7, 10 times, starting with 0 0 7 14 21 28 35 42 49 56 63 70 q){x+7}\\[10;5] // add 7, 10 times, starting with 5 5 12 19 26 33 40 47 54 61 68 75 q){x+7}/[10;5] // add 7, 10 times, starting with 5, over-only shows end result 75 we can also use while clause instead of integer n q){x+7}\\[{x<100};5] // add 7, while result <100, starting with 5 5 12 19 26 33 40 47 54 61 68 75 82 89 96 103 f/[x] - if n is not provided, iterate till output is same as previous result, or till last 2 results are same f\\[x] - iterate(scan) and f/[x] - converge(over) q){x%10}/[5] 0f q) q){x%10}\\[5] 5 0.5 0.05 0.005 0.0005 5e-005 5e-006 5e-007 5e-008","title":"monadic function - f"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#dyadic-function-f","text":"function takes 2 arguments f\\[a b c d] = a; f[a;b] f[f[a;b];c] ... or we can also provide initial number x - f\\[x;a b c d] = 100+a; 100+f[a;b]; 100+f[f[a;b];c] .. q)til 20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 q)+\\[til 20] 0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 q)+\\[100;til 20] 100 101 103 106 110 115 121 128 136 145 155 166 178 191 205 220 236 253 271 290","title":"dyadic function - f"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#exercise","text":"calculate depreciation of an asset over time function : depr:{[c;r] c*1-r%100} depreciation in 1 year q)depr[1000;10] // starting cost=1000, rate=10% 900f depreciation in 5 years or x years q)depr[;10]\\[5;1000] // starting cost=1000, rate=10%, over 5 years, using monadic version by keeping rate constant 1000 900f 810f 729f 656.1 590.49 check with different rate q)depr\\[1000;3 5 6 8 10] // cost=1000, rates=3 5 6 8 10% 970 921.5 866.21 796.9132 717.2219 different rate, different cost, 1 year q)depr\\[1000 2000 5000 10000;3 5 6 8 10] // cost=1000 2000 5000 10000, rates=3 5 6 8 10% 970 1940 4850 9700 921.5 1843 4607.5 9215 866.21 1732.42 4331.05 8662.1 796.9132 1593.826 3984.566 7969.132 717.2219 1434.444 3586.109 7172.219","title":"Exercise"},{"location":"kdb-q/keywords_joins_adverbs_attributes/4_adverbs/#exercise_1","text":"Question: Suppose we are given a vector of numbers (xx) and a step size (s). Write a function that will take x and s as arguments, and output a result vector. The result vector is constructed using the following procedure: 1. The xx value sets the mid-point of the step (e.g. if xx is 1 and s is 3, then the values -1,0,1,2 and 3 are included in that step range) 2. If the next xx value is within the current step range, then the step mid-point does not change (e.g. if xx is -1, then the step mid-point is still 1) 3. If the next xx value falls outside the current step range, the step mid-point is reset to that xx value (e.g. if xx is 4, then the new step mid-point is 4) 4. The current step mid-point is stored each time in the result vector Here are two examples to clarify the procedure: xx:1 -1 3 0 1 1 5 6 2 10 s:3 result:1 1 1 1 1 1 5 5 2 10 and xx:2 3 4 3 20 7 8 31 s:6 result:2 2 2 2 20 7 7 31 Answer: We will need to introduce 3 parameters: 1. x - the step size (this will take the value s) 2. y - the current step mid-point 3. z - the next value in the xx vector (we will see later how this may be achieved with an adverb) If z is within the current step range, it will satisfy: y - x < z < y + x ; this can be rearranged to give: x > abs ( z - y) So, if x>abs(z-y) is true, then the step mid-point does not change, and the value of y should be saved to the result vector. Alternatively, if x>abs(z-y) is false, then the step mid-point will change to the value of z, and so z should be saved to the result vector. The previous two comments can be expressed as an if-else statement: $[x>abs z - y; y; z] /the value returned, will be the step mid-point Let's digress back to the scan function e.g. q){x+y}\\[1 2 3 4] 1 3 6 10 The value returned by the above function is used as the next x value, and the next y value is taken from the next item in the list. This is exactly what we need to do in our problem. Thus, the solution is given by: {$[x>abs z - y; y; z]}[s]\\[xx]","title":"Exercise:"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/","text":"Attributes kdb has 4 attributes that can be applied to datastructures (generally lists) Attr Symbol Description sorted `s# Items are sorted - binary search grouped `g# A dictionary maps each occurence to position in array unique `u# no duplicates parted `p# stored same items together; dictionary maps first occurence Each attribute provides different performance benefits Attributes may be lost during modification Applying attributes q)list: 1 2 3 4 5 q)list 1 2 3 4 5 q)list: `s#1 2 3 4 5 q)list `s#1 2 3 4 5 we can check which attributes have been applied by checking meta data of the table q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[10000;50000] q)meta trades c | t f a -----| ----- time | p sym | s g src | s g price| f size | i we can also update a table by applying an attribute to a specific column q)update time:`s#time from `trades `trades q)meta trades c | t f a -----| ----- time | p s sym | s g src | s g price| f size | i applying attribute to a column in table may improve query speed they are commonly applied to column with many repeating values 1. Sorted `s tells q that list is sorted in ascending order if we use function asc to sorted a list, then q will automatically add `s# attribute Just having a list in ascending order wont apply `s# attribute, we need to explicitly tell q to apply it q)list: 1 2 3 4 5 q)list 1 2 3 4 5 q)asc list `s#1 2 3 4 5 q)list: `s#list q)list `s#1 2 3 4 5 `s# attribute optimises the searching on list by performing binary search on the list with `s# attribute search takes approx same time for element at start, mid and end without `s# attribute search takes more time as we search for element at end q)a: til 100000 q)a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 .. q)b:`s#til 100000 q)b `s#0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 .. q)\\t do[1000;a?2] 0 q)\\t do[10000;a?2] 4 q)\\t do[10000;a?1000] 20 q)\\t do[10000;a?10000-4] 87 q)\\t do[10000;a?100000-4] 505 q)\\t do[10000;b?100000-4] 11 q)\\t do[10000;b?10000-4] 10 q)\\t do[10000;b?1000] 7 q)\\t do[10000;b?2] 8 2. Unique `u tells q that list has unique elements and behind the scenes q creates a hash map, so it can query the elements in constant time q)n:1000000 q)list: til n q)listu: `u#til n q)\\t do[10000;list?`int$n%2] 2364 q)\\t do[10000;listu?`int$n%2] 24 `u# attribute is preserved when appending to list provided list still has unique elements after appending 3. Grouped `g when `g# attribute is applied to a list, q forms a lookup table of elements in list against list of their indexes q)52?`1 `o`d`d`h`e`d`l`e`m`p`a`l`k`k`p`p`f`d`m`h`f`g`o`o`i`n`d`m`e`l`f`n`a`b`g`f`f`o`.. // lookup table looks something like this: q)group 52?`1 a| 0 13 17 42 44 i| 1 4 l| ,2 f| 3 9 29 32 38 h| 5 18 21 25 26 b| 6 49 d| 7 14 23 27 41 c| 8 15 35 45 g| 10 28 m| 11 16 31 47 k| 12 19 22 30 33 34 j| 20 46 p| 24 51 e| 36 48 o| 37 39 40 n| 43 50 it causes q to take more time while applying `g# attribute and it takes more space(to store lookup table) q)n 1000000 q)syms: -1000?`4 q)t1:([]a:n#syms;b:n?1000 ) q)tg:([]a:`g#n#syms;b:n?1000 ) q)\\t do[10000;select from t1 where a=`lghi] 4930 q)\\t do[10000;select from tg where a=`lghi] 19 q) 4. Parted `p similar to grouped but here q only stores index of first occurence of an element `p# is not preserved when appending to list even if elements added maintains list partitions This is mostly used for on-disk data q)list `a`a`a`a`b`b`b`c`c q)`p#list `p#`a`a`a`a`b`b`b`c`c q)pl: `p#list q)pl `p#`a`a`a`a`b`b`b`c`c // underlying lookup table looks something like this: q)first each group pl a| 0 b| 4 c| 7 q)pl,`c // appending `c at end causes pl to lose `p# `a`a`a`a`b`b`b`c`c`c when querying from HDB we should use partition column first(date/month/year) and then use column with attribute, if we use any other column after date then attribute is lost q)\\l . q)quotes date sym time src bid ask bsize asize --------------------------------------------------------------------- 2014.04.21 aacj 2014.04.21D08:52:45.114000000 O 1500 5000 2014.04.21 aacj 2014.04.21D09:56:58.529000000 L 9500 8000 2014.04.21 aacj 2014.04.21D10:11:02.073000000 O 500 5500 2014.04.21 aacj 2014.04.21D11:05:48.110000000 O 5000 10000 2014.04.21 aacj 2014.04.21D11:57:34.256000000 N 6500 7000 2014.04.21 aacj 2014.04.21D13:13:43.109000000 O 6500 4000 2014.04.21 aacj 2014.04.21D14:53:19.787000000 N 2500 7500 2014.04.21 aacj 2014.04.21D15:42:19.164000000 L 4000 1000 2014.04.21 aacj 2014.04.21D16:14:48.307000000 L 9500 1500 2014.04.21 aacj 2014.04.21D16:24:17.107000000 O 8000 7500 2014.04.21 aakk 2014.04.21D08:33:13.751000000 N 6500 6500 2014.04.21 aakk 2014.04.21D09:00:10.954000000 N 5500 4000 2014.04.21 aakk 2014.04.21D09:10:39.732000000 N 9000 6000 2014.04.21 aakk 2014.04.21D10:31:16.183000000 L 7500 9500 2014.04.21 aakk 2014.04.21D11:05:31.205000000 L 3000 2500 2014.04.21 aakk 2014.04.21D11:06:45.876000000 O 8000 6500 2014.04.21 aakk 2014.04.21D11:44:05.643000000 O 2000 8500 2014.04.21 aakk 2014.04.21D11:47:34.308000000 N 8000 1000 2014.04.21 aakk 2014.04.21D12:25:59.515000000 L 10000 5000 2014.04.21 aakk 2014.04.21D12:26:02.080000000 N 1000 9500 .. q)meta quotes c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)meta select from quotes where date=2014.04.21 c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)meta select from quotes where date=2014.04.21,bid>50 c | t f a -----| ----- date | d sym | s time | p src | s bid | f ask | f bsize| i asize| i Speacial Case - step function using `s we can use `s# to create step function if `s# is not applied we cant search for values in between if `s# is applied we get values which is prevaling the argument value q)d:1 1.6 1.9 2.1!`a`b`c`d q)d 1 | a 1.6| b 1.9| c 2.1| d q)d[1.0] `a q)d[1.1] ` q)d:`s#1 1.6 1.9 2.1!`a`b`c`d q)d[1.0] `a q)d[1.1] `a q)d[1.6] `b q)d[1.85] `b same can be applied to tables as well q)t:`s#([sym:`A`A`B;date:2014.12.05 2014.12.22 2015.01.10] px: 10 12 15) q)t sym date | px --------------| -- A 2014.12.05| 10 A 2014.12.22| 12 B 2015.01.10| 15 q)meta t c | t f a ----| ----- sym | s p date| d px | j q)t(`A;2014.12.05) px| 10 q)t(`A;2014.12.21) px| 10 q)t(`A;2015.12.21) px| 12 q)t(`B;2015.12.21) px| 15","title":"Attributes"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#attributes","text":"kdb has 4 attributes that can be applied to datastructures (generally lists) Attr Symbol Description sorted `s# Items are sorted - binary search grouped `g# A dictionary maps each occurence to position in array unique `u# no duplicates parted `p# stored same items together; dictionary maps first occurence Each attribute provides different performance benefits Attributes may be lost during modification Applying attributes q)list: 1 2 3 4 5 q)list 1 2 3 4 5 q)list: `s#1 2 3 4 5 q)list `s#1 2 3 4 5 we can check which attributes have been applied by checking meta data of the table q)\\l 2_where_clause_fakedb.q USAGE: makedb[NUM QUOTES;NUM TRADES] eg makedb[100000;10000] makedb1[NUM QUOTES;NUM TRADES;DATE;RANDOMISED COUNT FACTOR] eg makedb1[100000;10000;.z.d;.3] makehdb[HDBDIR;NUM DAYS;APPROXIMATE NUM QUOTES PER DAY; APPROXIMATE NUM TRADES PER DAY] eg makehdb[`:hdb; 5; 100000; 10000] makecsv[CSVDIR;NUM DAYS;NUM QUOTES;NUM TRADES] q)makedb[10000;50000] q)meta trades c | t f a -----| ----- time | p sym | s g src | s g price| f size | i we can also update a table by applying an attribute to a specific column q)update time:`s#time from `trades `trades q)meta trades c | t f a -----| ----- time | p s sym | s g src | s g price| f size | i applying attribute to a column in table may improve query speed they are commonly applied to column with many repeating values","title":"Attributes"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#1-sorted-s","text":"tells q that list is sorted in ascending order if we use function asc to sorted a list, then q will automatically add `s# attribute Just having a list in ascending order wont apply `s# attribute, we need to explicitly tell q to apply it q)list: 1 2 3 4 5 q)list 1 2 3 4 5 q)asc list `s#1 2 3 4 5 q)list: `s#list q)list `s#1 2 3 4 5 `s# attribute optimises the searching on list by performing binary search on the list with `s# attribute search takes approx same time for element at start, mid and end without `s# attribute search takes more time as we search for element at end q)a: til 100000 q)a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 .. q)b:`s#til 100000 q)b `s#0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 .. q)\\t do[1000;a?2] 0 q)\\t do[10000;a?2] 4 q)\\t do[10000;a?1000] 20 q)\\t do[10000;a?10000-4] 87 q)\\t do[10000;a?100000-4] 505 q)\\t do[10000;b?100000-4] 11 q)\\t do[10000;b?10000-4] 10 q)\\t do[10000;b?1000] 7 q)\\t do[10000;b?2] 8","title":"1. Sorted `s"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#2-unique-u","text":"tells q that list has unique elements and behind the scenes q creates a hash map, so it can query the elements in constant time q)n:1000000 q)list: til n q)listu: `u#til n q)\\t do[10000;list?`int$n%2] 2364 q)\\t do[10000;listu?`int$n%2] 24 `u# attribute is preserved when appending to list provided list still has unique elements after appending","title":"2. Unique `u"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#3-grouped-g","text":"when `g# attribute is applied to a list, q forms a lookup table of elements in list against list of their indexes q)52?`1 `o`d`d`h`e`d`l`e`m`p`a`l`k`k`p`p`f`d`m`h`f`g`o`o`i`n`d`m`e`l`f`n`a`b`g`f`f`o`.. // lookup table looks something like this: q)group 52?`1 a| 0 13 17 42 44 i| 1 4 l| ,2 f| 3 9 29 32 38 h| 5 18 21 25 26 b| 6 49 d| 7 14 23 27 41 c| 8 15 35 45 g| 10 28 m| 11 16 31 47 k| 12 19 22 30 33 34 j| 20 46 p| 24 51 e| 36 48 o| 37 39 40 n| 43 50 it causes q to take more time while applying `g# attribute and it takes more space(to store lookup table) q)n 1000000 q)syms: -1000?`4 q)t1:([]a:n#syms;b:n?1000 ) q)tg:([]a:`g#n#syms;b:n?1000 ) q)\\t do[10000;select from t1 where a=`lghi] 4930 q)\\t do[10000;select from tg where a=`lghi] 19 q)","title":"3. Grouped `g"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#4-parted-p","text":"similar to grouped but here q only stores index of first occurence of an element `p# is not preserved when appending to list even if elements added maintains list partitions This is mostly used for on-disk data q)list `a`a`a`a`b`b`b`c`c q)`p#list `p#`a`a`a`a`b`b`b`c`c q)pl: `p#list q)pl `p#`a`a`a`a`b`b`b`c`c // underlying lookup table looks something like this: q)first each group pl a| 0 b| 4 c| 7 q)pl,`c // appending `c at end causes pl to lose `p# `a`a`a`a`b`b`b`c`c`c when querying from HDB we should use partition column first(date/month/year) and then use column with attribute, if we use any other column after date then attribute is lost q)\\l . q)quotes date sym time src bid ask bsize asize --------------------------------------------------------------------- 2014.04.21 aacj 2014.04.21D08:52:45.114000000 O 1500 5000 2014.04.21 aacj 2014.04.21D09:56:58.529000000 L 9500 8000 2014.04.21 aacj 2014.04.21D10:11:02.073000000 O 500 5500 2014.04.21 aacj 2014.04.21D11:05:48.110000000 O 5000 10000 2014.04.21 aacj 2014.04.21D11:57:34.256000000 N 6500 7000 2014.04.21 aacj 2014.04.21D13:13:43.109000000 O 6500 4000 2014.04.21 aacj 2014.04.21D14:53:19.787000000 N 2500 7500 2014.04.21 aacj 2014.04.21D15:42:19.164000000 L 4000 1000 2014.04.21 aacj 2014.04.21D16:14:48.307000000 L 9500 1500 2014.04.21 aacj 2014.04.21D16:24:17.107000000 O 8000 7500 2014.04.21 aakk 2014.04.21D08:33:13.751000000 N 6500 6500 2014.04.21 aakk 2014.04.21D09:00:10.954000000 N 5500 4000 2014.04.21 aakk 2014.04.21D09:10:39.732000000 N 9000 6000 2014.04.21 aakk 2014.04.21D10:31:16.183000000 L 7500 9500 2014.04.21 aakk 2014.04.21D11:05:31.205000000 L 3000 2500 2014.04.21 aakk 2014.04.21D11:06:45.876000000 O 8000 6500 2014.04.21 aakk 2014.04.21D11:44:05.643000000 O 2000 8500 2014.04.21 aakk 2014.04.21D11:47:34.308000000 N 8000 1000 2014.04.21 aakk 2014.04.21D12:25:59.515000000 L 10000 5000 2014.04.21 aakk 2014.04.21D12:26:02.080000000 N 1000 9500 .. q)meta quotes c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)meta select from quotes where date=2014.04.21 c | t f a -----| ----- date | d sym | s p time | p src | s bid | f ask | f bsize| i asize| i q)meta select from quotes where date=2014.04.21,bid>50 c | t f a -----| ----- date | d sym | s time | p src | s bid | f ask | f bsize| i asize| i","title":"4. Parted `p"},{"location":"kdb-q/keywords_joins_adverbs_attributes/5_attributes/#speacial-case-step-function-using-s","text":"we can use `s# to create step function if `s# is not applied we cant search for values in between if `s# is applied we get values which is prevaling the argument value q)d:1 1.6 1.9 2.1!`a`b`c`d q)d 1 | a 1.6| b 1.9| c 2.1| d q)d[1.0] `a q)d[1.1] ` q)d:`s#1 1.6 1.9 2.1!`a`b`c`d q)d[1.0] `a q)d[1.1] `a q)d[1.6] `b q)d[1.85] `b same can be applied to tables as well q)t:`s#([sym:`A`A`B;date:2014.12.05 2014.12.22 2015.01.10] px: 10 12 15) q)t sym date | px --------------| -- A 2014.12.05| 10 A 2014.12.22| 12 B 2015.01.10| 15 q)meta t c | t f a ----| ----- sym | s p date| d px | j q)t(`A;2014.12.05) px| 10 q)t(`A;2014.12.21) px| 10 q)t(`A;2015.12.21) px| 12 q)t(`B;2015.12.21) px| 15","title":"Speacial Case - step function using `s"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/","text":"Index Amend and Apply Operators @ and . @ and . build on the functionality provided by square bracket notation If x is a data structure, x[y] means 'Index' q)x 8 1 9 5 4 6 6 1 8 5 q)x[3] 5 If f is a function, f[y] means 'Apply': q)f {(x*2)+5} q)f[3] 11 @ and . provides more powerful, flexible and alternatives to square bracket notation @ is used for single-dimensional lists . is used for nested lists Index using @ and . If list is single-dimensional list and index is 2: q)list 4 9 2 7 0 1 9 2 1 8 q)index: 2 q)list[index] 2 then same can be acheived using @ operator as: q)@[list;index] 2 If list is nested list and row is 1 and column is 2: q)list 1 2 3 4 5 6 7 q)row:0 q)column:1 q)list[row][column] 2 q)list[row;column] 2 then same can be acheived using . operator as: q).[list;(row;column)] 2 q).[list;0 1] 2 Amend/Apply using @ Previously we used : operator to amend items in a single-dimensional list q)list \"ABCDE\" q)list[2]:\"Z\" q)list \"ABZDE\" Same can be acheived using @ for single-dimensional list, however we need to give list name as symbol for changes to be permanent q)list \"ABZDE\" q)@[list;2;:;\"K\"] \"ABKDE\" q)list \"ABZDE\" q)@[`list;2;:;\"K\"] `list q)list \"ABKDE\" we can also apply mathematical operator to list q)list 4 9 2 7 0 1 9 2 1 8 q)@[list;3;+;66] 4 9 2 73 0 1 9 2 1 8 q)list:(8 4 3;9 8 76;7 8) q)list 8 4 3 9 8 76 7 8 q).[list;1 2;+;100] 8 4 3 9 8 176 7 8 we can also update more than 1 item in the list q)list 4 9 2 7 0 1 9 2 1 8 q)@[list;0 1 2;:;44 55 66] 44 55 66 7 0 1 9 2 1 8 @ vs [] square brackets are easy to read for simple use cases, but there are cases where @ can be used where [] cannot [] can only be used with named variables but @ can be used without named variables, it can also be used with result of previous operation q)@[0000b;2;:;1b] 0010b q)@[10#.Q.A;2;:;\"H\"] \"ABHDEFGHIJ\" @ has a wider range of operations - square bracket allows us to append to a dictionary item q)d:(`a`b`c)!(1 2;3 4 5;6 7 8 9) q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 q)d[`c],:10 q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 10 but @ also allows us to prepend q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 10 q)@[d;`c] 6 7 8 9 10 q)@[d;`c;{y,x};55] a| 1 2 b| 3 4 5 c| 55 6 7 8 9 10 we can use @ with non-dyadic operators q)@[\"avcdf\";4;upper] \"avcdF\" to use a function taking more than 2 arguments, we create a monadic projection by fixing the other arguments inside the 3rd part of @ expression q)applyInterest:{[x;nperiods;rate] nperiods{x*1+y%100}[;rate]/x} q)account:`ram`bheem!12.33 2033.56 q)account ram | 12.33 bheem| 2033.56 q)@[account;`bheem;applyInterest[;2;5.5]] // fix nperiods to 2 and rate to 5.5 ram | 12.33 bheem| 2263.403 Advanced use of @ index Setup 2 structures: l is a mixed list of symbols and integers m is a mapping of symbol to integers we can apply the mapping at the indexes of the symbols q)l: (`a;1;2;`b;5;90) q)l `a 1 2 `b 5 90 q)m:`a`b!500 600 q)m a| 500 b| 600 q)@[l; where -11=type each l;m] 500 1 2 600 5 90 Using . with database tables we can use . to index into a table q)t:([sym:`MSFT`IBM] prc: 10.29 24.66; size: 100 200) q)t sym | prc size ----| ---------- MSFT| 10.29 100 IBM | 24.66 200 q).[t;(`MSFT;`prc)] 10.29 . also allows us to update entire object at once by passing an empty set of indexes - this allows us to amend each element of the list q)list:(1 2;3 4 5;6 7 8 9) q)list 1 2 3 4 5 6 7 8 9 q).[list;();+;90] 91 92 93 94 95 96 97 98 99 Convert @ to . we can convert an @ statement to . statement as @ is a speacial case of . q)list 1 2 3 4 5 6 7 8 9 q)f {2*x} q)@[list;1;f] 1 2 6 8 10 6 7 8 9 q).[list;enlist 1;f] 1 2 6 8 10 6 7 8 9 Apply using @ and . we have seen that when f is a function then f[x] means apply [] can be replaced with @ (for single argument)and . (for multiple arguments) q)f {2*x} q)f[2] 4 q)@[f;2] 4 Let's say we have list of lists with varying length and we want to flip it into a table - we can't do it straight away as lenghts are not same q)list:(1 2 3;4 5 ; 7 8 9 0) q)list 1 2 3 4 5 7 8 9 0 q)flip `a`b`c!list 'length [0] flip `a`b`c!list ^ instead we can use @ to fill the lists with 0N to make them of same lenght and then flip it into a table q)@[max[c]#0N;;:;]'[til each c:count each list;list] 1 2 3 4 5 7 8 9 0 q)flip `a`b`c!@[max[c]#0N;;:;]'[til each c:count each list;list] a b c ----- 1 4 7 2 5 8 3 9 0 Using @ on database tables we can use @ as simple version of functional select - here column name is used as symbol so it can be passed programatically q) @[select from trades where sym=`AAPL;`size;sums] Error trapping q)f {2*x} q)g {x*y} q)@[f;\"ABC\";{-2 \"Error: \",x;}] Error: type q).[g;(\"ABC\";5);{-2 \"Error: \",x;}] Error: type","title":"Index Amend"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#index-amend-and-apply","text":"","title":"Index Amend and Apply"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#operators-and","text":"@ and . build on the functionality provided by square bracket notation If x is a data structure, x[y] means 'Index' q)x 8 1 9 5 4 6 6 1 8 5 q)x[3] 5 If f is a function, f[y] means 'Apply': q)f {(x*2)+5} q)f[3] 11 @ and . provides more powerful, flexible and alternatives to square bracket notation @ is used for single-dimensional lists . is used for nested lists","title":"Operators @ and ."},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#index-using-and","text":"If list is single-dimensional list and index is 2: q)list 4 9 2 7 0 1 9 2 1 8 q)index: 2 q)list[index] 2 then same can be acheived using @ operator as: q)@[list;index] 2 If list is nested list and row is 1 and column is 2: q)list 1 2 3 4 5 6 7 q)row:0 q)column:1 q)list[row][column] 2 q)list[row;column] 2 then same can be acheived using . operator as: q).[list;(row;column)] 2 q).[list;0 1] 2","title":"Index using @ and ."},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#amendapply-using","text":"Previously we used : operator to amend items in a single-dimensional list q)list \"ABCDE\" q)list[2]:\"Z\" q)list \"ABZDE\" Same can be acheived using @ for single-dimensional list, however we need to give list name as symbol for changes to be permanent q)list \"ABZDE\" q)@[list;2;:;\"K\"] \"ABKDE\" q)list \"ABZDE\" q)@[`list;2;:;\"K\"] `list q)list \"ABKDE\" we can also apply mathematical operator to list q)list 4 9 2 7 0 1 9 2 1 8 q)@[list;3;+;66] 4 9 2 73 0 1 9 2 1 8 q)list:(8 4 3;9 8 76;7 8) q)list 8 4 3 9 8 76 7 8 q).[list;1 2;+;100] 8 4 3 9 8 176 7 8 we can also update more than 1 item in the list q)list 4 9 2 7 0 1 9 2 1 8 q)@[list;0 1 2;:;44 55 66] 44 55 66 7 0 1 9 2 1 8","title":"Amend/Apply using @"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#vs","text":"square brackets are easy to read for simple use cases, but there are cases where @ can be used where [] cannot [] can only be used with named variables but @ can be used without named variables, it can also be used with result of previous operation q)@[0000b;2;:;1b] 0010b q)@[10#.Q.A;2;:;\"H\"] \"ABHDEFGHIJ\" @ has a wider range of operations - square bracket allows us to append to a dictionary item q)d:(`a`b`c)!(1 2;3 4 5;6 7 8 9) q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 q)d[`c],:10 q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 10 but @ also allows us to prepend q)d a| 1 2 b| 3 4 5 c| 6 7 8 9 10 q)@[d;`c] 6 7 8 9 10 q)@[d;`c;{y,x};55] a| 1 2 b| 3 4 5 c| 55 6 7 8 9 10 we can use @ with non-dyadic operators q)@[\"avcdf\";4;upper] \"avcdF\" to use a function taking more than 2 arguments, we create a monadic projection by fixing the other arguments inside the 3rd part of @ expression q)applyInterest:{[x;nperiods;rate] nperiods{x*1+y%100}[;rate]/x} q)account:`ram`bheem!12.33 2033.56 q)account ram | 12.33 bheem| 2033.56 q)@[account;`bheem;applyInterest[;2;5.5]] // fix nperiods to 2 and rate to 5.5 ram | 12.33 bheem| 2263.403","title":"@ vs []"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#advanced-use-of-index","text":"Setup 2 structures: l is a mixed list of symbols and integers m is a mapping of symbol to integers we can apply the mapping at the indexes of the symbols q)l: (`a;1;2;`b;5;90) q)l `a 1 2 `b 5 90 q)m:`a`b!500 600 q)m a| 500 b| 600 q)@[l; where -11=type each l;m] 500 1 2 600 5 90","title":"Advanced use of @ index"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#using-with-database-tables","text":"we can use . to index into a table q)t:([sym:`MSFT`IBM] prc: 10.29 24.66; size: 100 200) q)t sym | prc size ----| ---------- MSFT| 10.29 100 IBM | 24.66 200 q).[t;(`MSFT;`prc)] 10.29 . also allows us to update entire object at once by passing an empty set of indexes - this allows us to amend each element of the list q)list:(1 2;3 4 5;6 7 8 9) q)list 1 2 3 4 5 6 7 8 9 q).[list;();+;90] 91 92 93 94 95 96 97 98 99","title":"Using . with database tables"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#convert-to","text":"we can convert an @ statement to . statement as @ is a speacial case of . q)list 1 2 3 4 5 6 7 8 9 q)f {2*x} q)@[list;1;f] 1 2 6 8 10 6 7 8 9 q).[list;enlist 1;f] 1 2 6 8 10 6 7 8 9","title":"Convert @ to ."},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#apply-using-and","text":"we have seen that when f is a function then f[x] means apply [] can be replaced with @ (for single argument)and . (for multiple arguments) q)f {2*x} q)f[2] 4 q)@[f;2] 4 Let's say we have list of lists with varying length and we want to flip it into a table - we can't do it straight away as lenghts are not same q)list:(1 2 3;4 5 ; 7 8 9 0) q)list 1 2 3 4 5 7 8 9 0 q)flip `a`b`c!list 'length [0] flip `a`b`c!list ^ instead we can use @ to fill the lists with 0N to make them of same lenght and then flip it into a table q)@[max[c]#0N;;:;]'[til each c:count each list;list] 1 2 3 4 5 7 8 9 0 q)flip `a`b`c!@[max[c]#0N;;:;]'[til each c:count each list;list] a b c ----- 1 4 7 2 5 8 3 9 0","title":"Apply using @ and ."},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#using-on-database-tables","text":"we can use @ as simple version of functional select - here column name is used as symbol so it can be passed programatically q) @[select from trades where sym=`AAPL;`size;sums]","title":"Using @ on database tables"},{"location":"kdb-q/keywords_joins_adverbs_attributes/6_index_amend_apply/#error-trapping","text":"q)f {2*x} q)g {x*y} q)@[f;\"ABC\";{-2 \"Error: \",x;}] Error: type q).[g;(\"ABC\";5);{-2 \"Error: \",x;}] Error: type","title":"Error trapping"}]}